<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="本项目使用  Java 语言实现了⼀个简易的数据库。MYDB 分为后端和前端，前后端通过 socket 进行交互。前端（客户端）负责读取用户输⼊，并发送到后端执行，输出返回结果，并等待下⼀次输⼊。MYDB 后端则需要解析 SQL，如果是合法的 SQL，就尝试执行并返回结果。">
<meta property="og:type" content="article">
<meta property="og:title" content="MYDB数据库">
<meta property="og:url" content="http://example.com/2022/08/10/MyDB/index.html">
<meta property="og:site_name" content="左红叶好老婆">
<meta property="og:description" content="本项目使用  Java 语言实现了⼀个简易的数据库。MYDB 分为后端和前端，前后端通过 socket 进行交互。前端（客户端）负责读取用户输⼊，并发送到后端执行，输出返回结果，并等待下⼀次输⼊。MYDB 后端则需要解析 SQL，如果是合法的 SQL，就尝试执行并返回结果。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-08-10T15:33:10.058Z">
<meta property="article:modified_time" content="2022-08-10T15:32:54.426Z">
<meta property="article:author" content="爱你的晶哥">
<meta property="article:tag" content="项目">
<meta property="article:tag" content="Mysql">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/2022/08/10/MyDB/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>MYDB数据库 | 左红叶好老婆</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">左红叶好老婆</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-resources">

    <a href="/resources/" rel="section"><i class="fa fa-download fa-fw"></i>resources</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/08/10/MyDB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="爱你的晶哥">
      <meta itemprop="description" content="对不起宝宝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="左红叶好老婆">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          MYDB数据库
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-08-10 23:33:10 / 修改时间：23:32:54" itemprop="dateCreated datePublished" datetime="2022-08-10T23:33:10+08:00">2022-08-10</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>本项目使用  Java 语言实现了⼀个简易的数据库。MYDB 分为后端和前端，前后端通过 socket 进行交互。前端（客户端）负责读取用户输⼊，并发送到后端执行，输出返回结果，并等待下⼀次输⼊。MYDB 后端则需要解析 SQL，如果是合法的 SQL，就尝试执行并返回结果。 </p>
<span id="more"></span>

<h1 id="MyDB-简介"><a href="#MyDB-简介" class="headerlink" title="MyDB 简介"></a>MyDB 简介</h1><h2 id="整体结构"><a href="#整体结构" class="headerlink" title="整体结构"></a>整体结构</h2><p>​	MYDB 分为后端和前端，前后端通过 socket 进行交互。前端（客户端）的职责很单一，读取用户输入，并发送到后端执行，输出返回结果，并等待下一次输入。MYDB 后端则需要解析 SQL，如果是合法的 SQL，就尝试执行并返回结果。不包括解析器，MYDB 的后端划分为五个模块，每个模块都又一定的职责，通过接口向其依赖的模块提供方法。	</p>
<p>​	以下是各个模块的介绍： </p>
<p>​		<strong>Transaction Manager</strong>– TM: begin, commit(T), abort(T), isActive(T),isCommitted(T),isAborted(T) TM提供了针对事务的开始, 提交, 回滚操作, 同时提供了对数据项状态的查询操作</p>
<p>​		<strong>Data Manager</strong>– DM: insert(x), update(x), read(x) DM提供了针对数据项(data item)的基本插入, 更新, 读取操作, 且这些操作是原子性的. DM会直接对数据库文件进行读写</p>
<p>​		<strong>Version Manager</strong>– VM: insert(X), update(X), read(X), delete(X) VM提供了针对记录(entry)的增删查改操作, VM在内部为每条记录维护多个版本, 并根据不同的事务, 返回不同的版本. VM对这些实现, 是建立在DM和TM的各个操作上的，还有一个事务可见性类Visibility</p>
<p>​		<strong>Table Manage</strong>r– TBM: execute(statement) TBM就是非常高层的模块了, 他能直接执行用户输入的语句(statement), 然后进行执行. TBM对语句的执行是建立在VM和IM提供的各个操作上的.</p>
<p>​		<strong>Index Manager</strong>– IM: value search(key), insert(key, value) IM提供了对索引的基本操作</p>
<h2 id="所需知识点"><a href="#所需知识点" class="headerlink" title="所需知识点"></a>所需知识点</h2><p>​	RandomAccessFile 类，随机存取文件流</p>
<p>​			RandomAccessFile 类支持 任意访问，即程序可以直接跳到文件的任意地方来读、写文件。</p>
<p>​			API：new RandomAccessFile (文件地址&#x2F;文件名,读取模式)、seek(位置)类似于fc.position方法</p>
<p>​	NIO：本项目所用网络IO模型为非阻塞IO</p>
<p>​			API：Channel通道负责传输，常用FileChannel处理本地文件</p>
<p>​					Buffer缓冲区负责存储，byteBuffer</p>
<p>​					Selector处理socket连接</p>
<h1 id="从最简单的-TM-开始"><a href="#从最简单的-TM-开始" class="headerlink" title="从最简单的 TM 开始"></a>从最简单的 TM 开始</h1><p>​	TransactionManager 通过维护一个 XID 格式文件来维护记录事务的状态（active 正在进行尚未提交，committed 已提交，aborted 已撤销&#x2F;回滚），并提供接口供其他模块来查询某个事务的状态。</p>
<h2 id="XID-文件简介"><a href="#XID-文件简介" class="headerlink" title="XID 文件简介"></a>XID 文件简介</h2><p>​	XID 文件定义：MyBD 中，每一个事务都对应着一个 xid，通过 id 唯一标识这个事务。XID 0 是特殊事务，称为 super Transaction,它的事务状态永远是 committed。正常事务的 XID 从 1 开始，自增且不可重复。</p>
<p>​	XID 文件给每个事务分配了一个字节的空间用来保存其状态，XID 文件的头部开辟了8字节的空间用来记录该 XID 管理的事务个数。于是，事务 xid 在文件中的状态就存储在 (xid-1)+8 字节处，xid-1 是因为 xid 0（Super XID） 的状态不需要记录。</p>
<h3 id="创建TM接口"><a href="#创建TM接口" class="headerlink" title="创建TM接口"></a>创建TM接口</h3><p>​	用来创建事务和查询事务状态。也实现了 create XID文件和 open XID文件的接口静态方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">TransactionManager</span> &#123;     </span><br><span class="line">    <span class="type">long</span> <span class="title function_">begin</span><span class="params">()</span>;                       <span class="comment">// 开启一个新事务    </span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">commit</span><span class="params">(<span class="type">long</span> xid)</span>;              <span class="comment">// 提交一个事务    </span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">abort</span><span class="params">(<span class="type">long</span> xid)</span>;               <span class="comment">// 取消一个事务    </span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isActive</span><span class="params">(<span class="type">long</span> xid)</span>;         <span class="comment">// 查询一个事务的状态是否是正在进行的状态   </span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isCommitted</span><span class="params">(<span class="type">long</span> xid)</span>;      <span class="comment">// 查询一个事务的状态是否是已提交    </span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isAborted</span><span class="params">(<span class="type">long</span> xid)</span>;        <span class="comment">// 查询一个事务的状态是否是已取消    </span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span>;                       <span class="comment">// 关闭TM </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建名为path的文件</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> TransactionManagerImpl <span class="title function_">create</span><span class="params">(String path)</span> &#123;</span><br><span class="line">        <span class="comment">// 定义文件的文件名为：路径+后缀</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(path+TransactionManagerImpl.XID_SUFFIX);</span><br><span class="line">	   <span class="comment">// 判断该文件不能创建新文件或者不能读或写</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(!f.createNewFile()) &#123;</span><br><span class="line">                Panic.panic(Error.FileExistsException);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            Panic.panic(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!f.canRead() || !f.canWrite()) &#123;</span><br><span class="line">            Panic.panic(Error.FileCannotRWException);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">FileChannel</span> <span class="variable">fc</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">RandomAccessFile</span> <span class="variable">raf</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 创建XID文件 和 连接IO设备的通道</span></span><br><span class="line">            raf = <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(f, <span class="string">&quot;rw&quot;</span>);<span class="comment">//rw	读操作和写操作都是允许的</span></span><br><span class="line">            fc = raf.getChannel();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">           Panic.panic(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 写空XID文件头</span></span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">buf</span> <span class="operator">=</span> ByteBuffer.wrap(<span class="keyword">new</span> <span class="title class_">byte</span>[TransactionManagerImpl.LEN_XID_HEADER_LENGTH]);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fc.position(<span class="number">0</span>);</span><br><span class="line">            fc.write(buf);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            Panic.panic(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回经过校验的XID文件</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TransactionManagerImpl</span>(raf, fc);</span><br><span class="line">    &#125;	</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 打开名为path的文件</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> TransactionManagerImpl <span class="title function_">open</span><span class="params">(String path)</span> &#123;</span><br><span class="line">        <span class="comment">// 文件名为：path+后缀</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(path+TransactionManagerImpl.XID_SUFFIX);</span><br><span class="line">        <span class="keyword">if</span>(!f.exists()) &#123;</span><br><span class="line">            Panic.panic(Error.FileNotExistsException);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!f.canRead() || !f.canWrite()) &#123;</span><br><span class="line">            Panic.panic(Error.FileCannotRWException);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">FileChannel</span> <span class="variable">fc</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">RandomAccessFile</span> <span class="variable">raf</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            raf = <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(f, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line">            fc = raf.getChannel();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">           Panic.panic(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回经过校验的XID文件</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TransactionManagerImpl</span>(raf, fc);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="1-定义常量和属性"><a href="#1-定义常量和属性" class="headerlink" title="1.定义常量和属性"></a>1.定义常量和属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// XID文件头长度</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">LEN_XID_HEADER_LENGTH</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line"><span class="comment">// 每个事务的占用长度</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">XID_FIELD_SIZE</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 事务的三种状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">byte</span> <span class="variable">FIELD_TRAN_ACTIVE</span>   <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">byte</span> <span class="variable">FIELD_TRAN_COMMITTED</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">byte</span> <span class="variable">FIELD_TRAN_ABORTED</span>  <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"><span class="comment">// 超级事务，永远为commited状态</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">SUPER_XID</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">// XID 文件后缀</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">XID_SUFFIX</span> <span class="operator">=</span> <span class="string">&quot;.xid&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>文件写都采用了 NIO 方式的 FileChannel通信管道。文件采用RandomAccessFile的API。</p>
<p>FileChannel无法设置为非阻塞模式，总是运行再阻塞模式下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NIO方式的FileChannel</span></span><br><span class="line"><span class="keyword">private</span> RandomAccessFile file;<span class="comment">// 用RAF类的API，对XID的文件进行操作</span></span><br><span class="line"><span class="keyword">private</span> FileChannel fc;<span class="comment">// FileChannel主要用于文件传输</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">long</span> xidCounter;<span class="comment">// id计数，代表事务的个数</span></span><br><span class="line"><span class="keyword">private</span> Lock counterLock;<span class="comment">// 可重入锁</span></span><br></pre></td></tr></table></figure>

<h3 id="2-校验-XID-文件保证其合法性"><a href="#2-校验-XID-文件保证其合法性" class="headerlink" title="2.校验 XID 文件保证其合法性"></a>2.校验 XID 文件保证其合法性</h3><p>​	在创建 TransactionManager 之后，首先需要校验 XID 文件保证其合法性，通过文件头 8 字节数字反推文件的理论长度，与实际长度做对比。对于校验没有通过的，会直接通过 panic 方法，强制停机。在一些基础模块中出现错误都会如此处理，无法恢复的错误只能直接停机。</p>
<p>在校验前，需要 getXidPosition 方法，来获取xid的状态在文件中的偏移。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据事务xid取得其在XID文件中对应的位置</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">long</span> <span class="title function_">getXidPosition</span><span class="params">(<span class="type">long</span> xid)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> LEN_XID_HEADER_LENGTH + (xid-<span class="number">1</span>)*XID_FIELD_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>校验 XID 文件保证其合法性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// raf 和 fc 由 create()方法调用</span></span><br><span class="line">TransactionManagerImpl(RandomAccessFile raf, FileChannel fc) &#123;</span><br><span class="line">    <span class="built_in">this</span>.file = raf;</span><br><span class="line">    <span class="built_in">this</span>.fc = fc;</span><br><span class="line">    counterLock = <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    checkXIDCounter();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 校验xid文件是否合法</span></span><br><span class="line"><span class="comment">     * 读取 XID_FILE_HEADER 中的 xidCounter【8字节数字】，根据它计算文件的理论长度，对比实际长度</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">checkXIDCounter</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">fileLen</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        fileLen = file.length();</span><br><span class="line">    &#125;<span class="keyword">catch</span> (IOException e1)&#123;</span><br><span class="line">        Panic.panic(Error.BadXIDFileException);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(fileLen &lt; LEN_XID_HEADER_LENGTH)&#123;</span><br><span class="line">        Panic.panic(Error.BadXIDFileException);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从堆空间中分配一个容量为 LEN_XID_HEADER_LENGTH 的byte数组作为缓冲区</span></span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">buf</span> <span class="operator">=</span> ByteBuffer.allocate(LEN_XID_HEADER_LENGTH);  </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">       fc.position(<span class="number">0</span>);<span class="comment">//调用position()方法获取FileChannel的当前位置,从0位置开始对数据进行读/写操作</span></span><br><span class="line">       fc.read(buf);    <span class="comment">//从fc读取数据 向buffer写入</span></span><br><span class="line">    &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">        Panic.panic(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//buf.array() 将xid文件的buffer转换为一个byte数组</span></span><br><span class="line">    <span class="comment">//Parser.parseLong(buf.array()) 将byte数组包装成一个buffer，并取其0-8位数字， 使用getLong()读取这8位数字返回 赋于xidCounter</span></span><br><span class="line">    <span class="built_in">this</span>.xidCounter = Parser.parseLong(buf.array());</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> getXidPosition(<span class="built_in">this</span>.xidCounter + <span class="number">1</span>);  <span class="comment">//获得事务xid文件的长度</span></span><br><span class="line">    <span class="keyword">if</span>(end != fileLen)&#123;</span><br><span class="line">        Panic.panic(Error.BadXIDFileException);  <span class="comment">//如果不相等则抛异常</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	对于校验没有通过的，会直接通过 panic 方法，强制停机。在一些基础模块中出现错误都会如此处理，无法恢复的错误只能直接停机。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Panic</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">panic</span><span class="params">(Exception err)</span> &#123;</span><br><span class="line">        err.printStackTrace();</span><br><span class="line">        System.exit(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-更新事务状态方法和更新XID文件头方法"><a href="#3-更新事务状态方法和更新XID文件头方法" class="headerlink" title="3.更新事务状态方法和更新XID文件头方法"></a>3.更新事务状态方法和更新XID文件头方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 更新xid事务的状态为status【更改xid文件的第一个数字，因为第一个数字代表状态】</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> xid     参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> status  要更新的状态</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">updateXID</span><span class="params">(<span class="type">long</span> xid, <span class="type">byte</span> status)</span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">offset</span> <span class="operator">=</span> getXidPosition(xid);  <span class="comment">//获得xid事务在事务文件中的位置offset</span></span><br><span class="line">        <span class="type">byte</span>[] tmp = <span class="keyword">new</span> <span class="title class_">byte</span>[XID_FIELD_SIZE];  <span class="comment">//建立一个字符数组</span></span><br><span class="line">        tmp[<span class="number">0</span>] = status;                        <span class="comment">//第一位数字代表其状态</span></span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">buf</span> <span class="operator">=</span> ByteBuffer.wrap(tmp);  <span class="comment">//将tmp字节数组包装成一个buffer</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            fc.position(offset);  <span class="comment">//定位到第一个位置</span></span><br><span class="line">            fc.write(buf);        <span class="comment">//更新后内容 写入fc 源文件也会更新</span></span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            Panic.panic(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            fc.force(<span class="literal">false</span>);  <span class="comment">//force方法强制同步缓存内容到文件中</span></span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            Panic.panic(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * xidCounter【事务个数】自增,并更新头文件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">incrXIDCounter</span><span class="params">()</span>&#123;</span><br><span class="line">        xidCounter++;  <span class="comment">//事务个数自增</span></span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">buf</span> <span class="operator">=</span> ByteBuffer.wrap(Parser.long2Byte(xidCounter));  <span class="comment">//wrap方法更新文件头buffer</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            fc.position(<span class="number">0</span>);</span><br><span class="line">            fc.write(buf);  <span class="comment">//buffer数据写入fc</span></span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            Panic.panic(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            fc.force(<span class="literal">false</span>);  <span class="comment">//force方法强制同步缓存内容到文件中</span></span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            Panic.panic(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-创建-begin-事务方法、创建提交事务方法、创建回滚事务方法"><a href="#4-创建-begin-事务方法、创建提交事务方法、创建回滚事务方法" class="headerlink" title="4.创建 begin 事务方法、创建提交事务方法、创建回滚事务方法"></a>4.创建 begin 事务方法、创建提交事务方法、创建回滚事务方法</h3><p>​	会开始一个事务（事务状态为正在进行 active），更具体的，首先设置 xidCounter+1 事务的状态为 committed，随后 xidCounter 自增，并更新文件头。</p>
<p>​	创建提交事务方法、创建回滚事务方法，直接调用updateXID(xid,status);即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 会开始一个事务，首先设置xidCounter + 1 事务的状态为committed 随后xidCounter自增 并更新文件头</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">begin</span><span class="params">()</span> &#123;</span><br><span class="line">    counterLock.lock();</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">xid</span> <span class="operator">=</span> xidCounter + <span class="number">1</span>;	<span class="comment">//事务数量加1 xid为开启新事务的xid</span></span><br><span class="line">        updateXID(xid, FIELD_TRAN_ACTIVE);	<span class="comment">//设置事务为active</span></span><br><span class="line">        incrXIDCounter();	<span class="comment">//事务个数自增 并且更新头文件</span></span><br><span class="line">        <span class="keyword">return</span> xid;		<span class="comment">//返回xid</span></span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        counterLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提交事务</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">commit</span><span class="params">(<span class="type">long</span> xid)</span> &#123;</span><br><span class="line">    <span class="comment">// 更新xid事务的状态为committed</span></span><br><span class="line">    updateXID(xid, FIELD_TRAN_COMMITTED); <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 回滚事务</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">abort</span><span class="params">(<span class="type">long</span> xid)</span> &#123;</span><br><span class="line">    <span class="comment">// 更新xid事务的状为abord</span></span><br><span class="line">    updateXID(xid, FIELD_TRAN_ABORTED); <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-创建-isActive、isCommitted-和-isAborted-方法"><a href="#5-创建-isActive、isCommitted-和-isAborted-方法" class="headerlink" title="5.创建 isActive、isCommitted 和 isAborted 方法"></a>5.创建 isActive、isCommitted 和 isAborted 方法</h3><p>​	以上三个方法都是检查某个事务 id 的状态，可以用一个通用的方法 checkXID 解决。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 检测xid事务是否处于status状态</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> xid</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> status</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">checkXid</span><span class="params">(<span class="type">long</span> xid, <span class="type">byte</span> status)</span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">offset</span> <span class="operator">=</span> getXidPosition(xid);  <span class="comment">//获取xid在事务文件的位置  offset为获取文件的第一个位置</span></span><br><span class="line">    <span class="comment">//事务状态的字符数组包装成buffer</span></span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">buf</span> <span class="operator">=</span> ByteBuffer.wrap(<span class="keyword">new</span> <span class="title class_">byte</span>[XID_FIELD_SIZE]);   </span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        fc.position(offset);  <span class="comment">//从offset位置开始</span></span><br><span class="line">        fc.read(buf);         <span class="comment">//读取fc中数据入buffer</span></span><br><span class="line">    &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">        Panic.panic(e);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> buf.array()[<span class="number">0</span>] == status;   <span class="comment">//检查buffer中的第一个元素是否是status的状态</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断事务是否处于正在进行状态</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isActive</span><span class="params">(<span class="type">long</span> xid)</span> &#123;</span><br><span class="line">    <span class="comment">// 超级事务不需要记录状态</span></span><br><span class="line">    <span class="keyword">if</span>(xid == SUPER_XID) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> checkXID(xid, FIELD_TRAN_ACTIVE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判断事务是否处于已提交状态</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isCommitted</span><span class="params">(<span class="type">long</span> xid)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(xid == SUPER_XID) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> checkXID(xid, FIELD_TRAN_COMMITTED);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判断事务是否处于已撤销状态</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAborted</span><span class="params">(<span class="type">long</span> xid)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(xid == SUPER_XID) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> checkXID(xid, FIELD_TRAN_ABORTED);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-关闭资源"><a href="#6-关闭资源" class="headerlink" title="6.关闭资源"></a>6.关闭资源</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 关闭管道和文件</span></span><br><span class="line">        fc.close();</span><br><span class="line">        file.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        Panic.panic(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="引用计数缓存框架和共享内存数组"><a href="#引用计数缓存框架和共享内存数组" class="headerlink" title="引用计数缓存框架和共享内存数组"></a>引用计数缓存框架和共享内存数组</h1><h2 id="实现引用计数策略的缓存框架"><a href="#实现引用计数策略的缓存框架" class="headerlink" title="实现引用计数策略的缓存框架"></a>实现引用计数策略的缓存框架</h2><p>​	AbstractCache 实现了一个 引用计数策略的缓存框架 只有上层模块主动释放引用 缓存在确保没有模块使用这个资源时才会驱逐资源</p>
<p>​	AbstractCache<T> 是一个抽象类 内部有两个抽象方法 留给实现类去实现具体的操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 多线程场景下，需要记录哪些资源正在从数据源获取</span></span><br><span class="line"><span class="keyword">private</span> HashMap&lt;Long, T&gt; cache;                     <span class="comment">// 实际缓存的数据</span></span><br><span class="line"><span class="keyword">private</span> HashMap&lt;Long, Integer&gt; references;          <span class="comment">// 元素的引用个数</span></span><br><span class="line"><span class="keyword">private</span> HashMap&lt;Long, Boolean&gt; getting;             <span class="comment">// 正在被获取的资源</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> maxResource;                            <span class="comment">// 缓存的最大缓存资源数</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;                              <span class="comment">// 缓存中元素的个数</span></span><br><span class="line"><span class="keyword">private</span> Lock lock;</span><br></pre></td></tr></table></figure>

<h3 id="1、抽象方法：不在缓存的资源获取，被驱逐的资源写回"><a href="#1、抽象方法：不在缓存的资源获取，被驱逐的资源写回" class="headerlink" title="1、抽象方法：不在缓存的资源获取，被驱逐的资源写回"></a>1、抽象方法：不在缓存的资源获取，被驱逐的资源写回</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 当资源不在缓存时的获取行为</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">protected</span> <span class="keyword">abstract</span> T <span class="title function_">getForCache</span><span class="params">(<span class="type">long</span> key)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 当资源被驱逐时的写回行为</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">releaseForCache</span><span class="params">(T obj)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="2、get-：获取资源方法"><a href="#2、get-：获取资源方法" class="headerlink" title="2、get()：获取资源方法"></a>2、get()：获取资源方法</h3><p>​	三部分：检查其他线程、缓存中获取、数据源中获取、</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * get()方法获取资源</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 资源 id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> T <span class="title function_">get</span><span class="params">(<span class="type">long</span> key)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">//首先进入一个死循环 尝试无限从缓存中获取数据 【有点类似自旋锁】</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">			<span class="comment">//检查是否有其他线程在从数据源获取该资源</span></span><br><span class="line">            <span class="keyword">if</span>(getting.containsKey(key))&#123;        </span><br><span class="line">                <span class="comment">// 请求的资源正在被其他线程获取</span></span><br><span class="line">                lock.unlock();</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1</span>);  <span class="comment">//就等会再来看看是否空闲</span></span><br><span class="line">                &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(cache.containsKey(key))&#123;              <span class="comment">//检查资源是否存在缓存中</span></span><br><span class="line">                <span class="comment">//资源存在缓存中 直接返回</span></span><br><span class="line">                <span class="type">T</span> <span class="variable">obj</span> <span class="operator">=</span> cache.get(key);</span><br><span class="line">                references.put(key, references.get(key) + <span class="number">1</span>); <span class="comment">//其引用计数加一</span></span><br><span class="line">                lock.unlock();</span><br><span class="line">                <span class="keyword">return</span> obj;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//尝试获取该资源</span></span><br><span class="line">            <span class="keyword">if</span>(maxResource &gt; <span class="number">0</span> &amp;&amp; count == maxResource)&#123;  <span class="comment">//缓存满了直接报错捏</span></span><br><span class="line">                lock.unlock();</span><br><span class="line">                <span class="keyword">throw</span> Error.CacheFullException;</span><br><span class="line">            &#125;</span><br><span class="line">            count++;                   <span class="comment">//资源数加1</span></span><br><span class="line">            getting.put(key,<span class="literal">true</span>);   <span class="comment">//需要在getting中注册一下  说明该线程准备好从数据库获取资源了</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">            <span class="keyword">break</span>;                    <span class="comment">//找到了直接break掉这个死循环</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从数据源获取资源 直接调用抽象方法</span></span><br><span class="line">        <span class="type">T</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            obj = getForCache(key);    <span class="comment">//数据源不在缓存中 直接从数据源获取 返回的数据包装成一个obj</span></span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            lock.lock();                <span class="comment">//如果出现异常</span></span><br><span class="line">            count--;                    <span class="comment">//其引用计数-1</span></span><br><span class="line">            getting.remove(key);        <span class="comment">//并从getting中删除key，说明此线程不再使用当前资源</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        lock.lock();</span><br><span class="line">        getting.remove(key);            <span class="comment">//从getting中删除key，说明此线程不再使用当前资源</span></span><br><span class="line">        cache.put(key, obj);            <span class="comment">//并将刚从数据源获取的数据加入缓存</span></span><br><span class="line">        references.put(key,<span class="number">1</span>);       <span class="comment">//为其建立一个引用计数</span></span><br><span class="line">        lock.unlock();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="3、release-：释放缓存方法"><a href="#3、release-：释放缓存方法" class="headerlink" title="3、release()：释放缓存方法"></a>3、release()：释放缓存方法</h3><p>​	release();，用于在上层模块不使用某个资源时，释放对资源的引用。当引用归零时，缓存就会驱逐这个资源。</p>
<p>​	释放一个缓存，需要 references-1，如果 references-1 &#x3D;&#x3D; 0，就可以回源（资源刷回数据源），并删除缓存所有相关结构。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 强行释放一个缓存</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">release</span><span class="params">(<span class="type">long</span> key)</span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">ref</span> <span class="operator">=</span> references.get(key) - <span class="number">1</span>;  <span class="comment">//直接将其引用数减去1</span></span><br><span class="line">            <span class="keyword">if</span>(ref == <span class="number">0</span>)&#123;                       <span class="comment">//如果引用数为 0</span></span><br><span class="line">                <span class="type">T</span> <span class="variable">obj</span> <span class="operator">=</span> cache.get(key);</span><br><span class="line">                releaseForCache(obj);           <span class="comment">//调用抽象方法数据 回源</span></span><br><span class="line">                references.remove(key);         <span class="comment">//删除引用计数</span></span><br><span class="line">                cache.remove(key);              <span class="comment">//从缓存中删除</span></span><br><span class="line">                count--;                        <span class="comment">//缓存资源数也减一</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//如果引用计数大于0  则说明该数据还待使用 将最新的引用计数同步到hashmap</span></span><br><span class="line">                references.put(key, ref);       </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="4、close-：关闭缓存方法"><a href="#4、close-：关闭缓存方法" class="headerlink" title="4、close()：关闭缓存方法"></a>4、close()：关闭缓存方法</h3><p>​	关闭缓存，需要将缓存中的所有资源强行回源</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 安全关闭缓存功能：关闭缓存 写回所有资源</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span>&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        Set&lt;Long&gt; keys = cache.keySet();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">long</span> key : keys)&#123;       <span class="comment">//遍历cache 其中所有缓存</span></span><br><span class="line">            release(key);               <span class="comment">//释放每个缓存</span></span><br><span class="line">            references.remove(key);     <span class="comment">//引用计数归0 删除</span></span><br><span class="line">            cache.remove(key);          <span class="comment">//缓存中数据全部删除</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="实现共享内存数组"><a href="#实现共享内存数组" class="headerlink" title="实现共享内存数组"></a>实现共享内存数组</h2><p>​	在 Java 中，当你执行类似 subArray 的操作时，只会在底层进行一个复制，无法同一片内存。 于是，SubArray 类，来（松散地）规定这个数组的可使用范围：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SubArray</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">byte</span>[] raw;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> start;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> end;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SubArray</span><span class="params">(<span class="type">byte</span>[] raw, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.raw = raw;</span><br><span class="line">        <span class="built_in">this</span>.start = start;</span><br><span class="line">        <span class="built_in">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="数据页的缓存与管理DM"><a href="#数据页的缓存与管理DM" class="headerlink" title="数据页的缓存与管理DM"></a>数据页的缓存与管理DM</h1><p>​	DM 直接管理数据库 DB 文件和日志文件。DM 的主要职责有：</p>
<p>​		1) 分页管理 DB 文件，并进行缓存；</p>
<p>​		2) 管理日志文件，保证在发生错误时可以根据日志进行恢复；</p>
<p>​		3) 抽象 DB 文件为 DataItem 供上层模块使用，并提供缓存。</p>
<p>​	本节主要内容就是 DM 模块 **向下 **对文件系统的抽象部分。DM 将文件系统抽象成页面，每次对文件系统的读写都是以页面为单位的。同样，从文件系统读进来的数据也是以页面为单位进行缓存的。</p>
<p>​	读、写、缓存都是以页面为单位进行的。</p>
<h2 id="数据页面缓存的实现"><a href="#数据页面缓存的实现" class="headerlink" title="数据页面缓存的实现"></a>数据页面缓存的实现</h2><h3 id="1、定义页面结构"><a href="#1、定义页面结构" class="headerlink" title="1、定义页面结构"></a>1、定义页面结构</h3><p>​	缓存页面需要先定义页面结构，注意这个页面是存储在内存中的，与已经持久化到磁盘的抽象页面有区别。默认数据页大小定为 8K，缓存页面采用第二节的缓存框架。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PageImpl</span> <span class="keyword">implements</span> <span class="title class_">Page</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> pageNumber;<span class="comment">// 页面的页号，从 1 开始</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">byte</span>[] data;<span class="comment">// 页面包含的实际字节数据</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> dirty;<span class="comment">// 是否为脏页（缓存驱逐时，脏页需要被写回磁盘）</span></span><br><span class="line">    <span class="keyword">private</span> Lock lock;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// PageCache（还未定义）的引用</span></span><br><span class="line">    <span class="keyword">private</span> PageCache pc;<span class="comment">// 用来方便在拿到 Page 的引用时可以快速对这个页面的缓存进行释放操作。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、定义页面缓存的接口"><a href="#2、定义页面缓存的接口" class="headerlink" title="2、定义页面缓存的接口"></a>2、定义页面缓存的接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PageCache</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PAGE_SIZE</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">13</span>;	<span class="comment">//默认页面缓存大小为8k</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">newPage</span><span class="params">(<span class="type">byte</span>[] initData)</span>;</span><br><span class="line">    Page <span class="title function_">getPage</span><span class="params">(<span class="type">int</span> pgno)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">release</span><span class="params">(Page page)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">truncateByBgno</span><span class="params">(<span class="type">int</span> maxPgno)</span>;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">getPageNumber</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">flushPage</span><span class="params">(Page pg)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3、页面缓存的具体实现类"><a href="#3、页面缓存的具体实现类" class="headerlink" title="3、页面缓存的具体实现类"></a>3、页面缓存的具体实现类</h3><p>​	需要继承抽象缓存框架，并且实现 getForCache() 和 releaseForCache() 两个抽象方法。由于数据源就是文件系统，getForCache() 直接从文件中读取，并包裹成 Page。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pgno 的前一页末尾，即最后一页的起点</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">pageOffset</span><span class="params">(<span class="type">int</span> pgno)</span> &#123;</span><br><span class="line">    <span class="comment">// 页号从 1 开始</span></span><br><span class="line">    <span class="keyword">return</span> (pgno-<span class="number">1</span>) * PAGE_SIZE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 根据 pageNumber 从数据库文件中读取页数据，并包裹成Page返回</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> Page <span class="title function_">getForCache</span><span class="params">(<span class="type">long</span> key)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">pgno</span> <span class="operator">=</span> (<span class="type">int</span>)key;</span><br><span class="line">    <span class="comment">// pgno 的前一页末尾</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">offset</span> <span class="operator">=</span> PageCacheImpl.pageOffset(pgno);</span><br><span class="line">	<span class="comment">// PAGE_SIZE == 8k,创建 8k 空间的缓冲区</span></span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">buf</span> <span class="operator">=</span> ByteBuffer.allocate(PAGE_SIZE);</span><br><span class="line">    fileLock.lock();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 定位到 fc 最后一页的起点，并把数据写入 buf</span></span><br><span class="line">        fc.position(offset);</span><br><span class="line">        fc.read(buf);	<span class="comment">//fc中数据读入buffer</span></span><br><span class="line">    &#125; <span class="keyword">catch</span>(IOException e) &#123;</span><br><span class="line">        Panic.panic(e);</span><br><span class="line">    &#125;</span><br><span class="line">    fileLock.unlock();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PageImpl</span>(pgno, buf.array(), <span class="built_in">this</span>);<span class="comment">// 根据页号、数据、页面缓存包装成Page返回</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 清空缓冲页面，写回数据源</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> pg</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">flush</span><span class="params">(Page pg)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">pgno</span> <span class="operator">=</span> pg.getPageNumber();  <span class="comment">//获取页面页号</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">offset</span> <span class="operator">=</span> pageOffset(pgno); <span class="comment">//获取页面数据起始索引</span></span><br><span class="line"></span><br><span class="line">    fileLock.lock();</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">buf</span> <span class="operator">=</span> ByteBuffer.wrap(pg.getData());     <span class="comment">//将页面数据包装成buffer</span></span><br><span class="line">        fc.position(offset);</span><br><span class="line">        fc.write(buf);                                      <span class="comment">//将buffer数据写入fc  回源</span></span><br><span class="line">        fc.force(<span class="literal">false</span>);</span><br><span class="line">    &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">        Panic.panic(e);</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        fileLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 驱逐页面时 只需要根据页面是否脏页 来决定此文件是否回源</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> pg</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">releaseForCache</span><span class="params">(Page pg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(pg.isDirty())&#123;</span><br><span class="line">        flush(pg);              <span class="comment">//如果是脏页将页面数据回源</span></span><br><span class="line">        pg.setDirty(<span class="literal">false</span>);     <span class="comment">//并且更新页面状态【是否脏页】</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4、记录数据库文件的页数"><a href="#4、记录数据库文件的页数" class="headerlink" title="4、记录数据库文件的页数"></a>4、记录数据库文件的页数</h3><p>​	PageCache 还使用了一个 AtomicInteger，来记录了当前打开的数据库文件有多少页。这个数字在数据库文件被打开时就会被计算，并在新建页面时自增。</p>
<p>注：同一条数据是不允许跨页存储的，这一点会从后面的章节中体现。这意味着，单条数据的大小不能超过数据库页面的大小。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据传过来的内容新建一个缓存页面</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> initData：页面数据</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回其页号</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">newPage</span><span class="params">(<span class="type">byte</span>[] initData)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">pgno</span> <span class="operator">=</span> pageNumbers.incrementAndGet();           <span class="comment">//页号原子自增</span></span><br><span class="line">    <span class="type">Page</span> <span class="variable">pg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PageImpl</span>(pgno, initData, <span class="literal">null</span>);   	<span class="comment">//根据页号 内容 初始化一个页面</span></span><br><span class="line">    flush(pg);                                          <span class="comment">//新建的页面需要立即写回</span></span><br><span class="line">    <span class="keyword">return</span> pgno;                                        <span class="comment">//返回页号</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="数据页面管理实现"><a href="#数据页面管理实现" class="headerlink" title="数据页面管理实现"></a>数据页面管理实现</h2><h3 id="1、第一页设计"><a href="#1、第一页设计" class="headerlink" title="1、第一页设计"></a>1、第一页设计</h3><p>​	数据库文件的第一页，通常用作一些特殊用途，比如存储一些元数据，用来启动检查什么的。	</p>
<p>​	MYDB 的第一页，只是用来做<strong>启动检查</strong>。具体的原理是，在每次数据库启动时，会生成一串随机字节，存储在 100 ~ 107 字节。在数据库正常关闭时，会将这串字节，拷贝到第一页的 108 ~ 115 字节。 这样数据库在每次启动时，就会检查第一页两处的字节是否相同，以此来判断上一次是否正常关闭。如果是异常关闭，就需要执行数据的恢复流程。</p>
<p>​	1）随机生成字节	2）拷贝字节	3）校验字节0</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">OF_VC</span> <span class="operator">=</span> <span class="number">100</span>;<span class="comment">// 存放字符串的起始位置</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">LEN_VC</span> <span class="operator">=</span> <span class="number">8</span>;<span class="comment">// 随机字节长度</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动时设置初始字节</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setVcOpen</span><span class="params">(Page pg)</span> &#123;</span><br><span class="line">    pg.setDirty(<span class="literal">true</span>);	<span class="comment">//设为脏页</span></span><br><span class="line">    setVcOpen(pg.getData());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 生成 8 位随机字节填入raw</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> raw</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setVcOpen</span><span class="params">(<span class="type">byte</span>[] raw)</span>&#123;</span><br><span class="line">    <span class="comment">//RandomUtil.randomBytes(LEN_VC) 生成8位随机字节</span></span><br><span class="line">    <span class="comment">//System.arraycopy(Object src,  int srcPos, Object dest, int destPos, int length)</span></span><br><span class="line">    <span class="comment">//静态本地方法【效率比虚拟机高很多】</span></span><br><span class="line">    <span class="comment">//数组间的复制：从源数组src取元素，范围为下标srcPos到srcPos+length-1，取出共length个元素</span></span><br><span class="line">    <span class="comment">//存放到目标数组中，存放位置为下标destPos到destPos+length-1。</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//从8位随机字节数组取出元素【范围是0 - LEN_VC-1】，取出LEN_VC个元素，存放入 raw 数组，</span></span><br><span class="line">    <span class="comment">//存放位置是OF_VC - OF_VC+LEN_VC-1</span></span><br><span class="line">    System.arraycopy(RandomUtil.randomBytes(LEN_VC),<span class="number">0</span>, raw, OF_VC, LEN_VC);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭时拷贝字节</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setVcClose</span><span class="params">(Page pg)</span> &#123;</span><br><span class="line">    pg.setDirty(<span class="literal">true</span>);</span><br><span class="line">    setVcClose(pg.getData());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setVcClose</span><span class="params">(<span class="type">byte</span>[] raw)</span> &#123;</span><br><span class="line">    <span class="comment">// 字符串，原数组中起始位置100，pg的数据，108开始，结束长度+8,</span></span><br><span class="line">    System.arraycopy(raw, OF_VC, raw, OF_VC+LEN_VC, LEN_VC);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 校验字节</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">checkVc</span><span class="params">(Page pg)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> checkVc(pg.getData());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">checkVc</span><span class="params">(<span class="type">byte</span>[] raw)</span> &#123;</span><br><span class="line">    <span class="comment">// 比较 Array 中数据是否相等</span></span><br><span class="line">    <span class="keyword">return</span> Arrays.equals(Arrays.copyOfRange(raw, OF_VC, OF_VC+LEN_VC), Arrays.copyOfRange(raw, OF_VC+LEN_VC, OF_VC+<span class="number">2</span>*LEN_VC));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2、普通页设计"><a href="#2、普通页设计" class="headerlink" title="2、普通页设计"></a>2、普通页设计</h3><p>​	PageX管理普通页：一个普通页面以一个2字节无符号数起始 表示这一页的空闲位置的偏移</p>
<p>​		&#x2F;&#x2F;FSO : free space offset  空闲空间偏移</p>
<p>​	普通页结构</p>
<p>​	    [FreeSpaceOffset] [Data]</p>
<p>​	    FreeSpaceOffset : 2字节 空闲位置开始偏移</p>
<p>​		Data：实际存储的数据。 </p>
<p>​	所以对普通页的管理，基本都是围绕着对 FSO（Free Space Offset）进行的。</p>
<p>​	例如向页面插入数据：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将 raw 插入 pg 中，返回插入位置</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">short</span> <span class="title function_">insert</span><span class="params">(Page pg, <span class="type">byte</span>[] raw)</span> &#123;</span><br><span class="line">    pg.setDirty(<span class="literal">true</span>);</span><br><span class="line">    <span class="type">short</span> <span class="variable">offset</span> <span class="operator">=</span> getFSO(pg.getData());	<span class="comment">//获取其fso</span></span><br><span class="line">    System.arraycopy(raw, <span class="number">0</span>, pg.getData(), offset, raw.length);	<span class="comment">//raw数据复制入页面pg数组</span></span><br><span class="line">    setFSO(pg.getData(), (<span class="type">short</span>)(offset + raw.length));</span><br><span class="line">    <span class="keyword">return</span> offset;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	在写入之前获取 FSO，来确定写入的位置，并在写入之后更新 FSO。FSO 的操作如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将ofData的前2个字节数据复制到 raw 数据</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setFSO</span><span class="params">(<span class="type">byte</span>[] raw, <span class="type">short</span> ofData)</span> &#123;</span><br><span class="line">    System.arraycopy(Parser.short2Byte(ofData), <span class="number">0</span>, raw, OF_FREE, OF_DATA);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取pg的FSO</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">short</span> <span class="title function_">getFSO</span><span class="params">(Page pg)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> getFSO(pg.getData());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取数据中 0-2 个字节的无符号数【fso】偏移量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">short</span> <span class="title function_">getFSO</span><span class="params">(<span class="type">byte</span>[] raw)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Parser.parseShort(Arrays.copyOfRange(raw, <span class="number">0</span>, <span class="number">2</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取页面的空闲空间大小</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getFreeSpace</span><span class="params">(Page pg)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> PageCache.PAGE_SIZE - (<span class="type">int</span>)getFSO(pg.getData());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	剩余两个函数 recoverInsert() 和 recoverUpdate() 用于在数据库崩溃后重新打开时，恢复例程直接插入数据以及修改数据使用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将raw插入pg中的offset位置，并将pg的offset设置为较大的offset</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">recoverInsert</span><span class="params">(Page pg, <span class="type">byte</span>[] raw, <span class="type">short</span> offset)</span> &#123;</span><br><span class="line">    pg.setDirty(<span class="literal">true</span>);</span><br><span class="line">    System.arraycopy(raw, <span class="number">0</span>, pg.getData(), offset, raw.length);</span><br><span class="line"></span><br><span class="line">    <span class="type">short</span> <span class="variable">rawFSO</span> <span class="operator">=</span> getFSO(pg.getData());</span><br><span class="line">    <span class="keyword">if</span>(rawFSO &lt; offset + raw.length) &#123;</span><br><span class="line">        setFSO(pg.getData(), (<span class="type">short</span>)(offset+raw.length));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将raw插入pg中的offset位置，不更新update</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">recoverUpdate</span><span class="params">(Page pg, <span class="type">byte</span>[] raw, <span class="type">short</span> offset)</span> &#123;</span><br><span class="line">    pg.setDirty(<span class="literal">true</span>);</span><br><span class="line">    System.arraycopy(raw, <span class="number">0</span>, pg.getData(), offset, raw.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="日志文件与恢复策略"><a href="#日志文件与恢复策略" class="headerlink" title="日志文件与恢复策略"></a>日志文件与恢复策略</h1><p>​	MYDB 提供了崩溃后的数据恢复功能，类似于 MySQL 的 redo log 和 bin log。DM 层在每次对底层数据操作时，都会记录一条日志到磁盘上。在数据库奔溃之后，再次启动时，可以根据日志的内容，恢复数据文件，保证其一致性。 </p>
<h2 id="日志读写实现"><a href="#日志读写实现" class="headerlink" title="日志读写实现"></a>日志读写实现</h2><h3 id="1、日志的格式"><a href="#1、日志的格式" class="headerlink" title="1、日志的格式"></a>1、日志的格式</h3><p>​	日志的二进制文件，按照如下的格式进行排布：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[XChecksum]</span><span class="selector-attr">[Log1]</span><span class="selector-attr">[Log2]</span><span class="selector-attr">[Log3]</span>...<span class="selector-attr">[LogN]</span><span class="selector-attr">[BadTail]</span></span><br></pre></td></tr></table></figure>

<p>​	其中 XChecksum 是一个四字节的整数，是对后续所有日志计算的checkSum（校验和）。Log1 ~ LogN 是常规的日志数据，BadTail 是在数据库崩溃时，没有来得及写完的日志数据，这个 BadTail 不一定存在。</p>
<p>​	 每条日志的格式如下：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[Size]</span><span class="selector-attr">[Checksum]</span><span class="selector-attr">[Data]</span></span><br></pre></td></tr></table></figure>

<p>​	其中，Size 是一个四字节int整数，标识了 Data 段的字节数。Checksum 则是该条日志的校验和。</p>
<h3 id="2、求单条日志的校验和"><a href="#2、求单条日志的校验和" class="headerlink" title="2、求单条日志的校验和"></a>2、求单条日志的校验和</h3><p>​	其实就是通过一个指定的种子 seed 实现的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SEED</span> <span class="operator">=</span> <span class="number">13331</span>;	<span class="comment">// 指定种子</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对所有日志求出校验和，求和就能得到日志文件的校验和xCheckSum。</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">calChecksum</span><span class="params">(<span class="type">int</span> xCheck, <span class="type">byte</span>[] log)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">byte</span> b : log) &#123;</span><br><span class="line">        xCheck = xCheck * SEED + b;		<span class="comment">//计算单条日志校验和 累加</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> xCheck;	返回总的校验和</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3、读取日志并返回数据"><a href="#3、读取日志并返回数据" class="headerlink" title="3、读取日志并返回数据"></a>3、读取日志并返回数据</h3><p>​	 Logger 被实现成迭代器模式，通过 next() 方法，不断地从文件中读取下一条日志，并将其中的 Data 解析出来并返回。next() 方法的实现主要依靠 internNext()，大致如下，其中 position 是当前日志文件读到的位置偏移：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">OF_SIZE</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">OF_CHECKSUM</span> <span class="operator">=</span> OF_SIZE + <span class="number">4</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">OF_DATA</span> <span class="operator">=</span> OF_CHECKSUM + <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">LOG_SUFFIX</span> <span class="operator">=</span> <span class="string">&quot;.log&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> RandomAccessFile file;</span><br><span class="line"><span class="keyword">private</span> FileChannel fc;</span><br><span class="line"><span class="keyword">private</span> Lock lock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">long</span> position;  <span class="comment">// 当前日志指针的位置</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">long</span> fileSize;  <span class="comment">// 初始化时记录，log操作不更新</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> xChecksum;	<span class="comment">// 日志文件总的校验和【单挑日志校验和相加】</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 不断的从文件中读取下一条日志 转成byte[]数组 并返回</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">byte</span>[] next() &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="type">byte</span>[] log = internNext();	<span class="comment">//调用internNext()方法 读取下一条日志 转成byte数组</span></span><br><span class="line">        <span class="keyword">if</span>(log == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Arrays.copyOfRange(log, OF_DATA, log.length);</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 不断的从文件中读取下一条日志，并将其中数据解析成byte数组之后返回</span></span><br><span class="line"><span class="comment"> * position：当前日志读取的位置偏移</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">byte</span>[] internNext()&#123;</span><br><span class="line">    <span class="keyword">if</span>(position + OF_DATA &gt;= fileSize)&#123;       <span class="comment">//如果读取到下一条日志超出了文件范围，表示没有日志了</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">tmp</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">4</span>);</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        fc.position(position);</span><br><span class="line">        fc.read(tmp);            			   <span class="comment">//fc中数据读入tmp</span></span><br><span class="line">    &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">        Panic.panic(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> Parser.parseInt(tmp.array());   <span class="comment">//返回tmp中4个字节的长度</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(position + size + OF_DATA &gt; fileSize)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//还会有剩下的日志数据</span></span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">buf</span> <span class="operator">=</span> ByteBuffer.allocate(OF_DATA + size);</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        fc.position(position);</span><br><span class="line">        fc.read(buf);         			<span class="comment">//fc中数据读入buf</span></span><br><span class="line">    &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">        Panic.panic(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">byte</span>[] log = buf.array();           <span class="comment">//buf里面数据转换成字节数组log</span></span><br><span class="line">    <span class="comment">//计算其总的校验和</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">checkSum1</span> <span class="operator">=</span> calChecksum(<span class="number">0</span>, Arrays.copyOfRange(log, OF_DATA, log.length));    </span><br><span class="line">    <span class="type">int</span> <span class="variable">checkSum2</span> <span class="operator">=</span> Parser.parseInt(Arrays.copyOfRange(log, OF_CHECKSUM, OF_DATA));           <span class="comment">//返回其理论校验和</span></span><br><span class="line">    <span class="keyword">if</span>(checkSum1 != checkSum2)&#123;   <span class="comment">//如果两个校验和不相等  日志无效</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    position += log.length;      <span class="comment">//position偏移到下一个日志开始位置 继续等待下一次读取</span></span><br><span class="line">    <span class="keyword">return</span> log;                  <span class="comment">//将单条日志信息返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4、检验日志文件"><a href="#4、检验日志文件" class="headerlink" title="4、检验日志文件"></a>4、检验日志文件</h3><p>​	在打开一个日志文件时，需要首先校验日志文件的 XChecksum，并移除文件尾部可能存在的 BadTail，由于 BadTail 该条日志尚未写入完成，文件的校验和也就不会包含该日志的校验和，去掉 BadTail 即可保证日志文件的一致性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * badtail表示该条日志尚未写入完成，文件的总校验和也不会包含这条未完成日志的校验和</span></span><br><span class="line"><span class="comment"> * 因此需要</span></span><br><span class="line"><span class="comment"> * 检查并移除bad tail 用于保证文件一致性</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">checkAndRemoveTail</span><span class="params">()</span>&#123;</span><br><span class="line">    rewind();       <span class="comment">//重置position为4</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">xCheck</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//无限循环从日志文件中读取下一条日志数据</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="type">byte</span>[] log = internNext();</span><br><span class="line">        <span class="keyword">if</span>(log == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        xCheck = calChecksum(xCheck, log);      <span class="comment">//并计算其总的校验和</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//校验和对不上就报错</span></span><br><span class="line">    <span class="keyword">if</span>(xCheck != xChecksum)&#123;</span><br><span class="line">       Panic.panic(Error.BadLogFileException);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从正常日志的末尾截断日志【删除之后的部分badtail】</span></span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        truncate(position);	<span class="comment">//truncate() 从position处截断文件</span></span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">        Panic.panic(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        file.seek(position);</span><br><span class="line">    &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">        Panic.panic(e);</span><br><span class="line">    &#125;</span><br><span class="line">    rewind(); 	<span class="comment">//position归位</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5、向日志文件写入日志"><a href="#5、向日志文件写入日志" class="headerlink" title="5、向日志文件写入日志"></a>5、向日志文件写入日志</h3><p>​	向日志文件写入日志时，也是首先将数据包裹成日志格式，写入文件后，再更新文件的校验和，更新校验和时，会刷新缓冲区，保证内容写入磁盘。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 向日志文件写入日志时，首先将数据包裹成日志格式</span></span><br><span class="line"><span class="comment">* 写入文件后 再更新 新文件的校验和</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> data</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">log</span><span class="params">(<span class="type">byte</span>[] data)</span> &#123;</span><br><span class="line">    <span class="type">byte</span>[] log = wrapLog(data);      		<span class="comment">//将data数据包装成字节数组【日志】</span></span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">buf</span> <span class="operator">=</span> ByteBuffer.wrap(log);  <span class="comment">//log数组包装成buffer</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        fc.position(fc.size());</span><br><span class="line">        fc.write(buf);         		<span class="comment">//从buf将日志数据写入文件到fc</span></span><br><span class="line">    &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">        Panic.panic(e);</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    updateXChecksum(log);   <span class="comment">//更新这一日志的校验和</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">updateXChecksum</span><span class="params">(<span class="type">byte</span>[] log)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.xChecksum = calChecksum(<span class="built_in">this</span>.xChecksum, log);	<span class="comment">//计算日志文件新的的校验和</span></span><br><span class="line">    fc.position(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//xchecksum转换为byte[]数组，wrap后写入fc</span></span><br><span class="line">    fc.write(ByteBuffer.wrap(Parser.int2Byte(xChecksum)));	</span><br><span class="line">    fc.force(<span class="literal">false</span>);	<span class="comment">//刷新缓冲区 保证内容写入磁盘</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* data日志数据包装wrap成字节数组  日志文件格式  size checksum data</span></span><br><span class="line"><span class="comment">* 就是在数据文件前面加入size【数据长度】和checksum【校验和】</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> data</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">byte</span>[] wrapLog(<span class="type">byte</span>[] data) &#123;</span><br><span class="line">    <span class="type">byte</span>[] checksum = Parser.int2Byte(calChecksum(<span class="number">0</span>, data));</span><br><span class="line">    <span class="type">byte</span>[] size = Parser.int2Byte(data.length);</span><br><span class="line">    <span class="keyword">return</span> Bytes.concat(size, checksum, data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="恢复策略"><a href="#恢复策略" class="headerlink" title="恢复策略"></a>恢复策略</h2><p>​	DM 为上层模块提供了两种操作，分别是<strong>插入新数据（I）和更新现有数据（U）</strong>。</p>
<p>​	DM 的日志策略很简单，一句话就是： 上层模块在对数据进行 I 和 U 操作之前，必须先进行对应的日志操作保证日志写入磁盘后，才进行数据操作。这个日志策略，使得 DM 对于数据操作的磁盘同步，可以更加随意。日志在数据操作之前，保证到达了磁盘，那么即使该数据操作最后没有来得及同步到磁盘，数据库就发生了崩溃，后续也可以通过磁盘上的日志恢复该数据。 对于两种数据操作，DM 记录的日志如下：</p>
<p>​	(Ti, I, A, x)，表示事务 Ti 在 A 位置插入了一条数据 x </p>
<p>​	(Ti, U, A, oldx, newx)，表示事务 Ti 将 A 位置的数据，从 oldx 更新成 newx</p>
<p>​	我们首先不考虑并发的情况，那么在某一时刻，只可能有一个事务在操作数据库。日志会看起来像下面那样：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(Ti, x, x), ..., (Ti, x, x), (Tj, x, x), ..., (Tj, x, x), (Tk, x, x), ..., (Tk, x, x)</span><br></pre></td></tr></table></figure>

<h3 id="1、单线程"><a href="#1、单线程" class="headerlink" title="1、单线程"></a>1、单线程</h3><p>​	由于单线程，Ti、Tj 和 Tk 的日志永远不会相交。这种情况下利用	很简单，假设日志中最后一个事务是 Ti：</p>
<p>​		1、对 Ti 之前所有的事务的日志，进行重做（redo）	</p>
<p>​		2、 接着检查 Ti 的状态（XID 文件），如果 Ti 的状态是已完成（包括 committed 和 aborted），就将 Ti 重做，否则进行撤销（undo） </p>
<p>​	接着，是如何对事务 T 进行 redo： </p>
<p>​		1、正序扫描事务 T 的所有日志 	</p>
<p>​		2、如果日志是插入操作 (Ti, I, A, x)，就将 x 重新插入 A 位置 	</p>
<p>​		3、如果日志是更新操作 (Ti, U, A, oldx, newx)，就将 A 位置的值设置为 newx </p>
<p>​	undo 也很好理解：</p>
<p>​		1、倒序扫描事务 T 的所有日志 	</p>
<p>​		2、如果日志是插入操作 (Ti, I, A, x)，就将 A 位置的数据删除	</p>
<p>​		3、 如果日志是更新操作 (Ti, U, A, oldx, newx)，就将 A 位置的值设置为 oldx </p>
<p>​	注意，MYDB 中其实没有真正的删除操作，对于插入操作的 undo，只是将其中的标志位设置为 invalid（vm 章节的内容）。</p>
<h3 id="2、多线程"><a href="#2、多线程" class="headerlink" title="2、多线程"></a>2、多线程</h3><p>​	规定1：正在进行的事务，不会读取其他任何未提交的事务产生的数据。</p>
<p>​	规定2：正在进行的事务，不会修改其他任何未提交的事务修改或产生的数据。</p>
<p>​	并发情况下日志的恢复：</p>
<p>​		1、重做所有崩溃时已完成（committed 或 aborted）的事务 	</p>
<p>​		2、撤销所有崩溃时未完成（active）的事务</p>
<p>​	在恢复后，数据库就会恢复到所有已完成事务结束，所有未完成事务尚未开始的状态。</p>
<h2 id="恢复策略的实现"><a href="#恢复策略的实现" class="headerlink" title="恢复策略的实现"></a>恢复策略的实现</h2><h3 id="1、规定日志格式"><a href="#1、规定日志格式" class="headerlink" title="1、规定日志格式"></a>1、规定日志格式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">byte</span> <span class="variable">LOG_TYPE_INSERT</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">byte</span> <span class="variable">LOG_TYPE_UPDATE</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">updateLog:</span><br><span class="line">[LogType] [XID] [UID] [OldRaw] [NewRaw]</span><br><span class="line"></span><br><span class="line">insertLog:</span><br><span class="line">[LogType] [XID] [Pgno] [Offset] [Raw]</span><br></pre></td></tr></table></figure>

<h3 id="2、实现-recover-例程"><a href="#2、实现-recover-例程" class="headerlink" title="2、实现 recover 例程"></a>2、实现 recover 例程</h3><p>​		重做已完成事务， 撤销所有未完成事务</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 恢复数据的主方法 传入事务 日志 和缓存</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> tm	事务</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> lg 日志</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> pc 缓存</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">recover</span><span class="params">(TransactionManager tm, Logger lg, PageCache pc)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Recovering...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    lg.rewind();</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxPgno</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">       <span class="type">byte</span>[] log = lg.next();   <span class="comment">//不断读取log日志信息</span></span><br><span class="line">       <span class="keyword">if</span>(log == <span class="literal">null</span>)&#123;</span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> pgno;</span><br><span class="line">        <span class="keyword">if</span>(isInsertLog(log))&#123;  <span class="comment">//如果该日志为插入日志  转换为对应格式</span></span><br><span class="line">            <span class="type">InsertLogInfo</span> <span class="variable">li</span> <span class="operator">=</span> parseInsertLog(log);		</span><br><span class="line">            pgno = li.pgno;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;  <span class="comment">//如果该日志为更新日志  转换为对应格式</span></span><br><span class="line">            <span class="type">UpdateLogInfo</span> <span class="variable">li</span> <span class="operator">=</span> parseUpdateLog(log);</span><br><span class="line">            pgno = li.pgno;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">//设置页面号</span></span><br><span class="line">         <span class="keyword">if</span>(pgno &gt; maxPgno)&#123;</span><br><span class="line">            maxPgno = pgno;</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(maxPgno == <span class="number">0</span>)&#123;</span><br><span class="line">    	maxPgno = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//从缓存中删除该页</span></span><br><span class="line">    pc.truncateByPgno(maxPgno);</span><br><span class="line">    System.out.println(<span class="string">&quot;Truncate to &quot;</span> + maxPgno + <span class="string">&quot; pages.&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重做该事务</span></span><br><span class="line">    redoTransactions(tm, lg, pc);</span><br><span class="line">    System.out.println(<span class="string">&quot;Redo Transactions Over&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//撤销该事务</span></span><br><span class="line">    undoTransactions(tm, lg, pc);</span><br><span class="line">    System.out.println(<span class="string">&quot;Undo Transactions Over&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//恢复完毕</span></span><br><span class="line">    System.out.println(<span class="string">&quot;Recovery Over&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 将log数据转换为插入日志【得到log里面xid， pgno， offset， raw等信息 封装成一个 InsertLogInfo】</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> log</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span>   返回 InsertLogInfo 对象</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> InsertLogInfo <span class="title function_">parseInsertLog</span><span class="params">(<span class="type">byte</span>[] log)</span> &#123;</span><br><span class="line">    <span class="type">InsertLogInfo</span> <span class="variable">li</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InsertLogInfo</span>();</span><br><span class="line">    li.xid = Parser.parseLong(Arrays.copyOfRange(log, OF_XID, OF_INSERT_PGNO));</span><br><span class="line">    li.pgno = Parser.parseInt(Arrays.copyOfRange(log, OF_INSERT_PGNO, OF_INSERT_OFFSET));</span><br><span class="line">    li.offset = Parser.parseShort(Arrays.copyOfRange(log, OF_INSERT_OFFSET, OF_INSERT_RAW));</span><br><span class="line">    li.raw = Arrays.copyOfRange(log, OF_INSERT_RAW, log.length);</span><br><span class="line">    <span class="keyword">return</span> li;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 将log数据转换为更新日志【得到当前log里面xid， pgno， offset， oldraw 和 newraw 等信息 </span></span><br><span class="line"><span class="comment">* 封装成一个 UpdateLogInfo】</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> log</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span>   返回 UpdateLogInfo 对象</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> UpdateLogInfo <span class="title function_">parseUpdateLog</span><span class="params">(<span class="type">byte</span>[] log)</span> &#123;</span><br><span class="line">    <span class="type">UpdateLogInfo</span> <span class="variable">li</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UpdateLogInfo</span>();</span><br><span class="line">    li.xid = Parser.parseLong(Arrays.copyOfRange(log, OF_XID, OF_UPDATE_UID));</span><br><span class="line">    <span class="type">long</span> <span class="variable">uid</span> <span class="operator">=</span> Parser.parseLong(Arrays.copyOfRange(log, OF_UPDATE_UID, OF_UPDATE_RAW));</span><br><span class="line">    li.offset = (<span class="type">short</span>)(uid &amp; ((<span class="number">1L</span> &lt;&lt; <span class="number">16</span>) - <span class="number">1</span>));</span><br><span class="line">    uid &gt;&gt;&gt;= <span class="number">32</span>;</span><br><span class="line">    li.pgno = (<span class="type">int</span>)(uid &amp; ((<span class="number">1L</span> &lt;&lt; <span class="number">32</span>) - <span class="number">1</span>));</span><br><span class="line">    <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> (log.length - OF_UPDATE_RAW) / <span class="number">2</span>;</span><br><span class="line">    li.oldRaw = Arrays.copyOfRange(log, OF_UPDATE_RAW, OF_UPDATE_RAW+length);</span><br><span class="line">    li.newRaw = Arrays.copyOfRange(log, OF_UPDATE_RAW+length, OF_UPDATE_RAW+length*<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> li;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 重做所有已完成的事务 参数为事务 日志 和缓存</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> tm</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> lg</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> pc</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">redoTransactions</span><span class="params">(TransactionManager tm, Logger lg, PageCache pc)</span> &#123;</span><br><span class="line">    lg.rewind();         <span class="comment">//定位到lg最开始位置</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="type">byte</span>[] log = lg.next();           <span class="comment">//不断读取log日志信息</span></span><br><span class="line">        <span class="keyword">if</span>(log == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果该日志为插入日志</span></span><br><span class="line">        <span class="keyword">if</span>(isInsertLog(log))&#123;         </span><br><span class="line">            <span class="comment">//log日志封装成InsertLogInfo 获得其xid pgno raw等信息</span></span><br><span class="line">            <span class="type">InsertLogInfo</span> <span class="variable">li</span> <span class="operator">=</span> parseInsertLog(log);          </span><br><span class="line">            <span class="type">long</span> <span class="variable">xid</span> <span class="operator">=</span> li.xid;</span><br><span class="line">            <span class="comment">//如果当前事务没有正在执行状态【已提交或者回滚】</span></span><br><span class="line">            <span class="keyword">if</span>(!tm.isActive(xid))&#123;                            </span><br><span class="line">                doInsertLog(pc, log, REDO);                   <span class="comment">//直接重做当前插入日志</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;                        <span class="comment">//该日志为更新日志</span></span><br><span class="line">            <span class="type">UpdateLogInfo</span> <span class="variable">xi</span> <span class="operator">=</span> parseUpdateLog(log);</span><br><span class="line">            <span class="type">long</span> <span class="variable">xid</span> <span class="operator">=</span> xi.xid;</span><br><span class="line">            <span class="keyword">if</span>(!tm.isActive(xid))&#123;</span><br><span class="line">                doUpdateLog(pc, log, REDO);                 <span class="comment">//直接重做当前更新日志</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 撤销所有未完成的事务</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> tm</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> lg</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> pc</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">undoTransactions</span><span class="params">(TransactionManager tm, Logger lg, PageCache pc)</span> &#123;</span><br><span class="line">    <span class="comment">//建立一个日志缓存哈希表：key：xid  value：对应的日志</span></span><br><span class="line">    Map&lt;Long, List&lt;<span class="type">byte</span>[]&gt;&gt; logCache = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();       </span><br><span class="line">    lg.rewind();</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="type">byte</span>[] log = lg.next();           <span class="comment">//不断读取log日志信息</span></span><br><span class="line">        <span class="keyword">if</span>(log == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(isInsertLog(log))&#123;             <span class="comment">//如果是插入日志</span></span><br><span class="line">            <span class="type">InsertLogInfo</span> <span class="variable">li</span> <span class="operator">=</span> parseInsertLog(log);</span><br><span class="line">            <span class="type">long</span> <span class="variable">xid</span> <span class="operator">=</span> li.xid;</span><br><span class="line">            <span class="keyword">if</span>(tm.isActive(xid))&#123;                   <span class="comment">//并且其事务处于正在执行状态</span></span><br><span class="line">                <span class="keyword">if</span>(!logCache.containsKey(xid))&#123;     <span class="comment">//如果日志缓存里没有当前事务</span></span><br><span class="line">                    logCache.put(xid, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());     <span class="comment">//将当前事务加入</span></span><br><span class="line">                &#125;</span><br><span class="line">                logCache.get(xid).add(log);   <span class="comment">//如果存在当前事务 直接将日志添加到xid对应的事务内</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;                          <span class="comment">//如果是更新日志</span></span><br><span class="line">            <span class="type">UpdateLogInfo</span> <span class="variable">xi</span> <span class="operator">=</span> parseUpdateLog(log);</span><br><span class="line">            <span class="type">long</span> <span class="variable">xid</span> <span class="operator">=</span> xi.xid;</span><br><span class="line">            <span class="keyword">if</span>(tm.isActive(xid))&#123;                  <span class="comment">//并且其事务正处于正在执行状态</span></span><br><span class="line">                <span class="keyword">if</span>(!logCache.containsKey(xid))&#123;     <span class="comment">//日志缓存里不含当前事务</span></span><br><span class="line">                    logCache.put(xid, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());       <span class="comment">//将当前事务加入</span></span><br><span class="line">                &#125;</span><br><span class="line">                logCache.get(xid).add(log);  <span class="comment">//如果存在当前事务 直接将日志添加到xid对应的事务内</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对所有active log进行倒序undo</span></span><br><span class="line">    <span class="comment">//遍历日志缓存</span></span><br><span class="line">    <span class="keyword">for</span>(Map.Entry&lt;Long, List&lt;<span class="type">byte</span>[]&gt;&gt; entry : logCache.entrySet())&#123;</span><br><span class="line">        List&lt;<span class="type">byte</span>[]&gt; logs = entry.getValue();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> logs.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="type">byte</span>[] log = logs.get(i);    <span class="comment">//其中的每个日志</span></span><br><span class="line">            <span class="comment">//如果是插入操作 则对其进行撤销插入操作</span></span><br><span class="line">            <span class="comment">//如果是更新操作 则对其进行撤销更新操作</span></span><br><span class="line">            <span class="keyword">if</span>(isInsertLog(log)) &#123;</span><br><span class="line">                doInsertLog(pc, log, UNDO);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                doUpdateLog(pc, log, UNDO);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        tm.abort(entry.getKey());     <span class="comment">//在事务管理器进行回滚</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3、updateLog-和-insertLog-的重做和撤销具体操作"><a href="#3、updateLog-和-insertLog-的重做和撤销具体操作" class="headerlink" title="3、updateLog 和 insertLog 的重做和撤销具体操作"></a>3、updateLog 和 insertLog 的重做和撤销具体操作</h3><p>​	分别合并成一个方法来实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 更新日志的【重做/撤销】处理</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> pc</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> log</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> flag</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">doUpdateLog</span><span class="params">(PageCache pc, <span class="type">byte</span>[] log, <span class="type">int</span> flag)</span> &#123;</span><br><span class="line">    <span class="type">int</span> pgno;</span><br><span class="line">    <span class="type">short</span> offset;</span><br><span class="line">    <span class="type">byte</span>[] raw;</span><br><span class="line">    <span class="keyword">if</span>(flag == REDO) &#123;</span><br><span class="line">        <span class="type">UpdateLogInfo</span> <span class="variable">xi</span> <span class="operator">=</span> parseUpdateLog(log);</span><br><span class="line">        pgno = xi.pgno;</span><br><span class="line">        offset = xi.offset;</span><br><span class="line">        raw = xi.newRaw;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">UpdateLogInfo</span> <span class="variable">xi</span> <span class="operator">=</span> parseUpdateLog(log);</span><br><span class="line">        pgno = xi.pgno;</span><br><span class="line">        offset = xi.offset;</span><br><span class="line">        raw = xi.oldRaw;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Page</span> <span class="variable">pg</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        pg = pc.getPage(pgno);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        Panic.panic(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        PageX.recoverUpdate(pg, raw, offset);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        pg.release();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 插入日志的【重做/撤销】处理</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> pc</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> log</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> flag</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">doInsertLog</span><span class="params">(PageCache pc, <span class="type">byte</span>[] log, <span class="type">int</span> flag)</span>&#123;</span><br><span class="line">    <span class="type">InsertLogInfo</span> <span class="variable">li</span> <span class="operator">=</span> parseInsertLog(log);</span><br><span class="line">    <span class="type">Page</span> <span class="variable">pg</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        pg = pc.getPage(li.pgno);          <span class="comment">//从缓存中获得该log对应的页面</span></span><br><span class="line">    &#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">        Panic.panic(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(flag == UNDO) &#123;      <span class="comment">//如果是撤销还原操作 还需要额外操作【删除原来数据-&gt;设置为无效】</span></span><br><span class="line">            DataItem.setDataItemRawInvalid(li.raw);</span><br><span class="line">        &#125;</span><br><span class="line">        PageX.recoverInsert(pg, li.raw, li.offset); <span class="comment">//将当前日志的raw数据插入页面 从offset处</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        pg.release();                                    <span class="comment">//驱逐缓存</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>PS. doInsertLog() 方法中的删除，使用的是 DataItem.setDataItemRawInvalid(li.raw);，dataItem 将在下一节中说明，大致的作用，就是将该条 DataItem 的有效位设置为无效，来进行逻辑删除。</p>
<h1 id="页面索引和-DM-的实现"><a href="#页面索引和-DM-的实现" class="headerlink" title="页面索引和 DM 的实现"></a>页面索引和 DM 的实现</h1><p>​	 实现了一个简单的页面索引。并且实现了 DM 层对于上层的抽象：DataItem。</p>
<h2 id="页面索引实现"><a href="#页面索引实现" class="headerlink" title="页面索引实现"></a>页面索引实现</h2><p>​	页面索引，缓存了每一页的空闲空间。用于在上层模块进行<strong>插入操作时，能够快速找到一个合适空间的页面</strong>，而无需从磁盘或者缓存中检查每一个页面的信息。 </p>
<p>​	将一页的空间划分成了 40 个区间。在启动时，就会遍历所有的页面信息，获取页面的空闲空间，安排到这 40 个区间中。insert 在请求一个页时，会首先将所需的空间向上取整，映射到某一个区间，随后取出这个区间的任何一页，都可以满足需求。 </p>
<h3 id="1、PageIndex-页面索引的实现"><a href="#1、PageIndex-页面索引的实现" class="headerlink" title="1、PageIndex 页面索引的实现"></a>1、PageIndex 页面索引的实现</h3><p>​	通过一个 List 类型的数组：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PageIndex</span> &#123;</span><br><span class="line">    <span class="comment">// 将一页划成40个区间</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">INTERVALS_NO</span> <span class="operator">=</span> <span class="number">40</span>;	<span class="comment">//区间个数</span></span><br><span class="line">    <span class="comment">//页面划分每个空间的 size</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">THRESHOLD</span> <span class="operator">=</span> PageCache.PAGE_SIZE / INTERVALS_NO;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> List&lt;PageInfo&gt;[] lists;	<span class="comment">//pageIndex的实现 一个list类型数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、从-PageIndex-中获取页面"><a href="#2、从-PageIndex-中获取页面" class="headerlink" title="2、从 PageIndex 中获取页面"></a>2、从 PageIndex 中获取页面</h3><p>​	上层用 insert 在请求一个页时，会首先将所需的空间向上取整，算出区间号，直接取区间中的一页即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从 pageIndex 中获取页面</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> spaceSize  参数为空闲空间大小</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> PageInfo <span class="title function_">select</span><span class="params">(<span class="type">int</span> spaceSize)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> spaceSize / THRESHOLD;		<span class="comment">//空闲空间分配出来的区间个数</span></span><br><span class="line">    <span class="keyword">if</span>(number &lt; INTERVALS_NO) number ++;	<span class="comment">//向上取整</span></span><br><span class="line">    <span class="keyword">while</span>(number &lt;= INTERVALS_NO) &#123;</span><br><span class="line">        <span class="keyword">if</span>(lists[number].size() == <span class="number">0</span>) &#123;</span><br><span class="line">            number ++;		<span class="comment">//算出区间号</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="comment">//被选择的页面 会直接从PageIndex中remove移除【意味着同一个页面不允许并发写】</span></span><br><span class="line">        <span class="keyword">return</span> lists[number].remove(<span class="number">0</span>);	<span class="comment">//返回pageInfo【PageInfo中包含页号和空闲空间大小的信息】</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3、页面重新插入-PageIndex-中"><a href="#3、页面重新插入-PageIndex-中" class="headerlink" title="3、页面重新插入 PageIndex 中"></a>3、页面重新插入 PageIndex 中</h3><p>​	返回的 PageInfo 中包含页号和空闲空间大小的信息。 可以注意到，被选择的页，会直接从 PageIndex 中移除，这意味着，同一个页面是不允许并发写的。在上层模块使用完这个页面后，需要将其重新插入 PageIndex：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在上层模块使用完这个页面后 会将其重新插入pageIndex</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> pgno</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> freeSpace</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> pgno, <span class="type">int</span> freeSpace)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> freeSpace / THRESHOLD;</span><br><span class="line">    lists[number].add(<span class="keyword">new</span> <span class="title class_">PageInfo</span>(pgno, freeSpace));	<span class="comment">//重新加入list</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4、创建-DM-时所需的工作"><a href="#4、创建-DM-时所需的工作" class="headerlink" title="4、创建 DM 时所需的工作"></a>4、创建 DM 时所需的工作</h3><p>​	在 DataManager 被创建时，需要获取所有页面并填充 PageIndex：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 初始化PageIndex</span></span><br><span class="line"><span class="comment">* 在 DataManager被创建时 需要获取所有页面 并填充 PageIndex</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fillPageIndex</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">pageNumber</span> <span class="operator">=</span> pc.getPageNumber();  <span class="comment">//获取页面的数量</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= pageNumber; i++)&#123;</span><br><span class="line">        <span class="type">Page</span> <span class="variable">pg</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            pg = pc.getPage(i);  <span class="comment">//获取具体的每一页</span></span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            Panic.panic(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将其页号和空闲空间大小重新插入pageIndex</span></span><br><span class="line">        pIndex.add(pg.getPageNumber(), PageX.getFreeSpace(pg));</span><br><span class="line">        pg.release();  <span class="comment">//驱逐页面缓存【防止撑爆缓存】</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	注意在使用完 Page 后需要及时 release，否则可能会撑爆缓存。 </p>
<h2 id="DataItem-抽象的实现"><a href="#DataItem-抽象的实现" class="headerlink" title="DataItem 抽象的实现"></a>DataItem 抽象的实现</h2><p>​	DataItem 是 DM 层向上层<strong>提供的数据</strong>的抽象。</p>
<p>​	<strong>上层模块获取数据的过程：通过地址，向 DM 请求到对应的 DataItem，再获取到其中的数据。</strong> </p>
<h3 id="1、DataItem-的结构和日志结构"><a href="#1、DataItem-的结构和日志结构" class="headerlink" title="1、DataItem 的结构和日志结构"></a>1、DataItem 的结构和日志结构</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataItemImpl</span> <span class="keyword">implements</span> <span class="title class_">DataItem</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> SubArray raw;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">byte</span>[] oldRaw;</span><br><span class="line">    <span class="keyword">private</span> DataManagerImpl dm;	<span class="comment">//dm 的引用</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> uid;</span><br><span class="line">    <span class="keyword">private</span> Page pg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	保存一个 dm 的引用是因为其释放依赖 dm 的释放（dm 同时实现了缓存接口，用于缓存 DataItem），以及修改数据时落日志。 DataItem 中保存的数据，结构如下：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[ValidFlag]</span> <span class="selector-attr">[DataSize]</span> <span class="selector-attr">[Data]</span></span><br></pre></td></tr></table></figure>

<p>​	其中 ValidFlag 占用 1 字节，标识了该 DataItem 是否有效，0为合法，1为非法。</p>
<p>​	删除一个 DataItem，只需要简单地将其有效位设置为 0。</p>
<p>​	DataSize 占用 2 字节，标识了后面 Data 的长度。 </p>
<h3 id="2、data-：方法获取-DataItem-数据"><a href="#2、data-：方法获取-DataItem-数据" class="headerlink" title="2、data()：方法获取 DataItem 数据"></a>2、data()：方法获取 DataItem 数据</h3><p>​	上层模块在获取到 DataItem 后，可以通过 data() 方法，该方法返回的数组是数据共享的，而不是拷贝实现的，所以使用了 SubArray。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//共享内存数组</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> SubArray <span class="title function_">data</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SubArray</span>(raw.raw, raw.start+OF_DATA, raw.end);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3、修改-DataItem-的相关-before-unBefore-after-方法"><a href="#3、修改-DataItem-的相关-before-unBefore-after-方法" class="headerlink" title="3、修改 DataItem 的相关 before();unBefore();after() 方法"></a>3、修改 DataItem 的相关 before();unBefore();after() 方法</h3><p>​	在上层模块试图对 DataItem 进行修改时，需要遵循一定的流程：在修改之前需要调用 before() 方法，想要撤销修改时，调用 unBefore() 方法，在修改完成后，调用 after() 方法。整个流程，主要是为了保存前相数据，并及时添加日志。DM 会保证对 DataItem 的修改是原子性的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//修改数据前，加写锁 设置脏页</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span> &#123;</span><br><span class="line">    wLock.lock();</span><br><span class="line">    pg.setDirty(<span class="literal">true</span>);</span><br><span class="line">    System.arraycopy(raw.raw, raw.start, oldRaw, <span class="number">0</span>, oldRaw.length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//想要撤销修改时，还原旧的数据oldraw</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unBefore</span><span class="params">()</span> &#123;</span><br><span class="line">    System.arraycopy(oldRaw, <span class="number">0</span>, raw.raw, raw.start, oldRaw.length);</span><br><span class="line">    wLock.unlock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//修改完成后，生成对应事务的日志 解锁</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">(<span class="type">long</span> xid)</span> &#123;</span><br><span class="line">    dm.logDataItem(xid, <span class="built_in">this</span>);</span><br><span class="line">    wLock.unlock();</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h3 id="4、release-：方法释放-DataItem-缓存"><a href="#4、release-：方法释放-DataItem-缓存" class="headerlink" title="4、release()：方法释放 DataItem 缓存"></a>4、release()：方法释放 DataItem 缓存</h3><p>​	在使用完 DataItem 后，也应当及时调用 release() 方法，释放掉 DM 中的 DataItem 的缓存（DM 缓存接口提供的方法）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">release</span><span class="params">()</span> &#123;</span><br><span class="line">    dm.releaseDataItem(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="DM-的实现"><a href="#DM-的实现" class="headerlink" title="DM 的实现"></a>DM 的实现</h2><p>​	DataManager 是 DM 层直接<strong>对外提供方法</strong>的类，实现了对外的几个方法。同时，因为 DataItem 的缓存是存放在 DM 层中的，所以也实现了 DataItem 对象的缓存。</p>
<h3 id="1、解析-DM-的-DataItem-缓存，并获取其中的数据"><a href="#1、解析-DM-的-DataItem-缓存，并获取其中的数据" class="headerlink" title="1、解析 DM 的 DataItem 缓存，并获取其中的数据"></a>1、解析 DM 的 DataItem 缓存，并获取其中的数据</h3><p>​	DataItem 存储的 key，是由页号和页内偏移组成的一个 8 字节无符号整数，页号和偏移各占 4字节。   </p>
<p>​	getForCache()，只需要从 key 中解析出页号，从 pageCache 中获取到页面，再根据偏移，解析出 DataItem 即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> DataItem <span class="title function_">getForCache</span><span class="params">(<span class="type">long</span> uid)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">short</span> <span class="variable">offset</span> <span class="operator">=</span> (<span class="type">short</span>)(uid &amp; ((<span class="number">1L</span> &lt;&lt; <span class="number">16</span>) - <span class="number">1</span>));		<span class="comment">//key中获取的偏移量</span></span><br><span class="line">    uid &gt;&gt;&gt;= <span class="number">32</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">pgno</span> <span class="operator">=</span> (<span class="type">int</span>)(uid &amp; ((<span class="number">1L</span> &lt;&lt; <span class="number">32</span>) - <span class="number">1</span>));			<span class="comment">//key中获得的页号</span></span><br><span class="line">    <span class="type">Page</span> <span class="variable">pg</span> <span class="operator">=</span> pc.getPage(pgno);							<span class="comment">//从缓存中获取对应页面</span></span><br><span class="line">    <span class="keyword">return</span> DataItem.parseDataItem(pg, offset, <span class="built_in">this</span>);	<span class="comment">//页面转换成DataItem</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、释放-DM-的-DataItem-缓存，把数据写回数据源"><a href="#2、释放-DM-的-DataItem-缓存，把数据写回数据源" class="headerlink" title="2、释放 DM 的 DataItem 缓存，把数据写回数据源"></a>2、释放 DM 的 DataItem 缓存，把数据写回数据源</h3><p>​	DataItem 缓存释放 需要将 DataItem 写回数据源 直接调用页面 page 的 release 方法，因为对文件的读写是以页面为单位：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">releaseForCache</span><span class="params">(DataItem di)</span> &#123;</span><br><span class="line">    di.page().release();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3、创建-DataManager-文件"><a href="#3、创建-DataManager-文件" class="headerlink" title="3、创建 DataManager 文件"></a>3、创建 DataManager 文件</h3><p>​	从已有文件创建 DataManager 和从空文件创建 DataManager 的流程稍有不同，除了 PageCache 和 Logger 的创建方式有所不同以外，从空文件创建首先需要对第一页进行初始化，而从已有文件创建，则是需要对第一页进行校验，来判断是否需要执行恢复流程。并重新对第一页生成随机字节。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> DataManager <span class="title function_">create</span><span class="params">(String path, <span class="type">long</span> mem, TransactionManager tm)</span> &#123;</span><br><span class="line">    <span class="type">PageCache</span> <span class="variable">pc</span> <span class="operator">=</span> PageCache.create(path, mem);</span><br><span class="line">    <span class="type">Logger</span> <span class="variable">lg</span> <span class="operator">=</span> Logger.create(path);</span><br><span class="line">    <span class="type">DataManagerImpl</span> <span class="variable">dm</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataManagerImpl</span>(pc, lg, tm);</span><br><span class="line">    dm.initPageOne();</span><br><span class="line">    <span class="keyword">return</span> dm;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> DataManager <span class="title function_">open</span><span class="params">(String path, <span class="type">long</span> mem, TransactionManager tm)</span> &#123;</span><br><span class="line">    <span class="type">PageCache</span> <span class="variable">pc</span> <span class="operator">=</span> PageCache.open(path, mem);</span><br><span class="line">    <span class="type">Logger</span> <span class="variable">lg</span> <span class="operator">=</span> Logger.open(path);</span><br><span class="line">    <span class="type">DataManagerImpl</span> <span class="variable">dm</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataManagerImpl</span>(pc, lg, tm);</span><br><span class="line">    <span class="comment">//从已有文件创建需要对第一页进行校验 判断其上一次数据库是否正常关闭</span></span><br><span class="line">    <span class="keyword">if</span>(!dm.loadCheckPageOne()) &#123;</span><br><span class="line">        Recover.recover(tm, lg, pc);	 <span class="comment">//如果异常关闭 则需要进行恢复流程</span></span><br><span class="line">    &#125;</span><br><span class="line">    dm.fillPageIndex();					<span class="comment">//获取所有历史页面【已有文件】数据 填充pageIndex</span></span><br><span class="line">    PageOne.setVcOpen(dm.pageOne);		<span class="comment">//重新生成 8 位随机字节填充第一页</span></span><br><span class="line">    dm.pc.flushPage(dm.pageOne);		<span class="comment">//清空缓存 数据写回数据源</span></span><br><span class="line">    <span class="keyword">return</span> dm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4、初始化或检验-DM-文件第一页"><a href="#4、初始化或检验-DM-文件第一页" class="headerlink" title="4、初始化或检验 DM 文件第一页"></a>4、初始化或检验 DM 文件第一页</h3><p>​	由于从空文件创建首先需要对第一页进行初始化，而从已有文件创建，则是需要对第一页进行校验。初始化第一页，和校验第一页，基本都是调用 PageOne 页面中的方法实现的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在创建文件时初始化PageOne</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">initPageOne</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">pgno</span> <span class="operator">=</span> pc.newPage(PageOne.InitRaw());</span><br><span class="line">    <span class="keyword">assert</span> pgno == <span class="number">1</span>;	/断言 检查pgno是否等于<span class="number">1</span>  检查是否为第一页</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        pageOne = pc.getPage(pgno);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        Panic.panic(e);</span><br><span class="line">    &#125;</span><br><span class="line">    pc.flushPage(pageOne);	<span class="comment">//清空pageOne页面 返回数据源</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 在打开已有文件时时读入PageOne，并验证数据库上一次是否正常关闭</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">loadCheckPageOne</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        pageOne = pc.getPage(<span class="number">1</span>);	<span class="comment">//获取缓存中第一页的数据【第一页数据用作启动检查】</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        Panic.panic(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> PageOne.checkVc(pageOne);		<span class="comment">//检查数据库是否正常关闭</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="5、read-insert-DM-方法实现-R-和-I"><a href="#5、read-insert-DM-方法实现-R-和-I" class="headerlink" title="5、read();insert(); DM 方法实现 R 和 I"></a>5、read();insert(); DM 方法实现 R 和 I</h3><p>​	DM 层提供了三个功能供上层使用，分别是读、插入和修改。修改是通过读出的 DataItem 实现的，于是 DataManager 只需要提供 read() 和 insert() 方法。 </p>
<p>​	read() 根据 UID 从缓存中获取 DataItem，并校验有效位：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> DataItem <span class="title function_">read</span><span class="params">(<span class="type">long</span> uid)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">//从缓存中获取【缓存没有数据需要去数据库查询】 uid 对应的数据  包装成 DataItem</span></span><br><span class="line">    <span class="type">DataItemImpl</span> <span class="variable">di</span> <span class="operator">=</span> (DataItemImpl)<span class="built_in">super</span>.get(uid);	</span><br><span class="line">    <span class="keyword">if</span>(!di.isValid()) &#123;		<span class="comment">//数据无效则直接释放</span></span><br><span class="line">        di.release();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> di;	<span class="comment">//返回数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	insert() 方法，在 pageIndex 中获取一个足以存储插入内容的页面的页号，获取页面后，首先需要写入插入日志，接着才可以通过 pageX 插入数据，并返回插入位置的偏移。最后需要将页面信息重新插入 pageIndex。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 将数据包装成dataItem插入页面</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> xid</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> data</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">* <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">insert</span><span class="params">(<span class="type">long</span> xid, <span class="type">byte</span>[] data)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">byte</span>[] raw = DataItem.wrapDataItemRaw(data);       <span class="comment">//data 包装成 DataItem</span></span><br><span class="line">    <span class="keyword">if</span>(raw.length &gt; PageX.MAX_FREE_SPACE)&#123;  <span class="comment">//如果 DataItem 的长度比普通页面的空闲空间要大 报错</span></span><br><span class="line">        <span class="keyword">throw</span> Error.DataTooLargeException;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">PageInfo</span> <span class="variable">pi</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">        pi = pIndex.select(raw.length);   <span class="comment">//在 PageIndex 中获取一个足够插入内容的页面</span></span><br><span class="line">        <span class="keyword">if</span>(pi != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//根据初始化页面 新建一个缓存页面 获得其页号</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">newPgno</span> <span class="operator">=</span> pc.newPage(PageX.initRaw());  </span><br><span class="line">            pIndex.add(newPgno, PageX.MAX_FREE_SPACE);  <span class="comment">//将其重新插入 PageIndex</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pi == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> Error.DatabaseBusyException;  <span class="comment">//pi 为空表示没有获取到页面 报错</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">Page</span> <span class="variable">pg</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">freeSpace</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        pg = pc.getPage(pi.pgno);   <span class="comment">//通过刚才获取到页面的页号从缓存中查询页面</span></span><br><span class="line">        <span class="type">byte</span>[] log = Recover.insertLog(xid, pg, raw);       <span class="comment">//封装成插入日志</span></span><br><span class="line">        logger.log(log);                            <span class="comment">//写入插入日志</span></span><br><span class="line"></span><br><span class="line">        <span class="type">short</span> <span class="variable">offset</span> <span class="operator">=</span> PageX.insert(pg, raw);       <span class="comment">//页面插入 pageX</span></span><br><span class="line"></span><br><span class="line">        pg.release();                               <span class="comment">//释放页面</span></span><br><span class="line">        <span class="keyword">return</span> Types.addressToUid(pi.pgno, offset); <span class="comment">//返回插入位置的偏移量</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//最后需要将页面信息重新插入 PageIndex</span></span><br><span class="line">        <span class="keyword">if</span>(pg != <span class="literal">null</span>)&#123;</span><br><span class="line">            pIndex.add(pi.pgno, PageX.getFreeSpace(pg));</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            pIndex.add(pi.pgno, freeSpace);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6、close-方法，关闭-DM"><a href="#6、close-方法，关闭-DM" class="headerlink" title="6、close();方法，关闭 DM"></a>6、close();方法，关闭 DM</h3><p>​	DataManager 正常关闭时，需要执行缓存和日志的关闭流程，不要忘了设置第一页的字节校验：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.close();	<span class="comment">//关闭缓存</span></span><br><span class="line">    logger.close();	<span class="comment">//关闭日志</span></span><br><span class="line"> </span><br><span class="line">    PageOne.setVcClose(pageOne);	<span class="comment">//设置数据库关闭时的有效性检查 字节</span></span><br><span class="line">    pageOne.release();				<span class="comment">//释放页面</span></span><br><span class="line">    pc.close();						<span class="comment">//关闭缓存</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="记录的版本与事务隔离VM"><a href="#记录的版本与事务隔离VM" class="headerlink" title="记录的版本与事务隔离VM"></a>记录的版本与事务隔离VM</h1><p>​	从这一章开始，我们开始讨论 Version Manager。VM 基于两段锁协议实现了调度序列的可串行化，并实现了 MVCC 以消除读写阻塞。同时实现了两种隔离级别。</p>
<p>​	类似于 Data Manager 是 MYDB 的数据管理核心，Version Manager 是 MYDB 的事务和数据版本的管理核心。VM 的一个很重要的职责，就是实现了调度序列的可串行化。MYDB 采用两段锁协议（2PL）来实现。当采用 2PL 时，如果某个事务 i 已经对 x 加锁，且另一个事务 j 也想操作 x，但是这个操作与事务 i 之前的操作相互冲突的话，事务 j 就会被阻塞。譬如，T1 已经因为 U1(x) 锁定了 x，那么 T2 对 x 的读或者写操作都会被阻塞，T2 必须等待 T1 释放掉对 x 的锁。</p>
<p>​	<strong>简单来讲就是两个不同事务的 U 操作 或者 两个不同事务的 U、R 操作会造成冲突。所以采用 MVCC 来实现调度序列的可串行化。</strong></p>
<h2 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h2><p>​	在介绍 MVCC 之前，首先明确记录和版本的概念。 DM 层向上层提供了数据项（Data Item）的概念，VM 通过管理所有的数据项，向上层提供了记录【Entry】的概念。</p>
<p>​	VM 向上层抽象出 entry 记录  上层模块操作数据就是操作 Entry</p>
<p>​	VM 在其内部会为每个记录维护多个版本 version ，每当上层模块对某个记录进行修改时，VM会为这个记录创造一个新的版本</p>
<p>​	MYDB 通过 MVCC，降低了事务的阻塞概率。譬如，T1 想要更新记录 X 的值，于是 T1 需要首先获取 X 的锁，接着更新，也就是创建了一个新的 X 的版本，假设为 x3。假设 T1 还没有释放 X 的锁时，T2 想要读取 X 的值，这时候就不会阻塞，MYDB 会返回一个较老版本的 X，例如 x2。这样最后执行的结果，就等价于，T2 先执行，T1 后执行，调度序列依然是可串行化的。如果 X 没有一个更老的版本，那只能等待 T1 释放锁了。所以只是降低了概率。</p>
<p>规定1：正在进行的事务，不会读取其他任何未提交的事务产生的数据。 </p>
<p>规定2：正在进行的事务，不会修改其他任何未提交的事务修改或产生的数据。</p>
<p>由于 2PL 和 MVCC，我们可以看到，这两个条件都被很轻易地满足了。</p>
<h2 id="记录的实现"><a href="#记录的实现" class="headerlink" title="记录的实现"></a>记录的实现</h2><p>​	对于一条记录来说，MYDB 使用 Entry 类维护了其结构。虽然理论上，MVCC 实现了多版本，但是在实现中，VM 并没有提供 Update 操作，对于字段的更新操作由后面的表和字段管理（TBM）实现。所以在 VM 的实现中，一条记录只有一个版本。 </p>
<h3 id="1、存在-DataItem-中记录"><a href="#1、存在-DataItem-中记录" class="headerlink" title="1、存在 DataItem 中记录"></a>1、存在 DataItem 中记录</h3><p>​	一条Entry存储在一条 DataItem 中，所以 Entry 中保存一个 DataItem 的引用即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Entry</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">OF_XMIN</span> <span class="operator">=</span> <span class="number">0</span>;			</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">OF_XMAX</span> <span class="operator">=</span> OF_XMIN+<span class="number">8</span>;	</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">OF_DATA</span> <span class="operator">=</span> OF_XMAX+<span class="number">8</span>;	</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> uid;</span><br><span class="line">    <span class="keyword">private</span> DataItem dataItem;	<span class="comment">//需要保存一个DataItem的引用</span></span><br><span class="line">    <span class="keyword">private</span> VersionManager vm;</span><br><span class="line">	</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//从缓存中加载entry</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Entry <span class="title function_">loadEntry</span><span class="params">(VersionManager vm, <span class="type">long</span> uid)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">DataItem</span> <span class="variable">di</span> <span class="operator">=</span> ((VersionManagerImpl)vm).dm.read(uid); <span class="comment">//从缓存中根据uid获取dataitem</span></span><br><span class="line">        <span class="keyword">return</span> newEntry(vm, di, uid);	<span class="comment">//将dataitem uid 包装成一个entry</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//释放缓存</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">        dataItem.release();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、Entry-中存储的数据格式"><a href="#2、Entry-中存储的数据格式" class="headerlink" title="2、Entry 中存储的数据格式"></a>2、Entry 中存储的数据格式</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[XMIN]</span> <span class="selector-attr">[XMAX]</span> <span class="selector-attr">[DATA]</span></span><br></pre></td></tr></table></figure>

<p>​	XMIN 是创建该条记录（版本）的事务编号，而 XMAX 则是删除该条记录（版本）的事务编号。DATA 就是这条记录持有的数据。根据这个结构，在创建记录时调用的 wrapEntryRaw() 方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 创建记录时</span></span><br><span class="line"><span class="comment">* 将一条数据包装成一条 entry 记录 【包含xmin xmax data三部分】</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> xid</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> data</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] wrapEntryRaw(<span class="type">long</span> xid, <span class="type">byte</span>[] data) &#123;</span><br><span class="line">    <span class="type">byte</span>[] xmin = Parser.long2Byte(xid);</span><br><span class="line">    <span class="type">byte</span>[] xmax = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">8</span>];</span><br><span class="line">    <span class="keyword">return</span> Bytes.concat(xmin, xmax, data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3、获取记录中的数据"><a href="#3、获取记录中的数据" class="headerlink" title="3、获取记录中的数据"></a>3、获取记录中的数据</h3><p>​	同样，如果要获取记录中持有的数据，也就需要按照这个结构来解析，并且以拷贝的形式返回数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解析 以拷贝的形式返回内容</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">byte</span>[] data() &#123;</span><br><span class="line">    dataItem.rLock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">SubArray</span> <span class="variable">sa</span> <span class="operator">=</span> dataItem.data();	<span class="comment">//共享数组中存储dataItem数据</span></span><br><span class="line">        <span class="type">byte</span>[] data = <span class="keyword">new</span> <span class="title class_">byte</span>[sa.end - sa.start - OF_DATA];	<span class="comment">//拷贝到一个byte数组</span></span><br><span class="line">        System.arraycopy(sa.raw, sa.start+OF_DATA, data, <span class="number">0</span>, data.length);</span><br><span class="line">        <span class="keyword">return</span> data;	<span class="comment">//返回byte数组</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        dataItem.rUnLock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	获取当前entry记录的创建者和最后修改者方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 获取当前记录 entry 的创建者</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getXmin</span><span class="params">()</span>&#123;</span><br><span class="line">    dataItem.rLock();</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="type">SubArray</span> <span class="variable">sa</span> <span class="operator">=</span> dataItem.data();</span><br><span class="line">        <span class="keyword">return</span> Parser.parseLong(Arrays.copyOfRange(sa.raw, sa.start + OF_XMIN, sa.start + OF_XMAX));</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        dataItem.rUnLock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 获取当前 entry 记录的 最后修改者</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getXmax</span><span class="params">()</span>&#123;</span><br><span class="line">    dataItem.rLock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">SubArray</span> <span class="variable">sa</span> <span class="operator">=</span> dataItem.data();</span><br><span class="line">        <span class="keyword">return</span> Parser.parseLong(Arrays.copyOfRange(sa.raw, sa.start + OF_XMAX, sa.start + OF_DATA));</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        dataItem.rUnLock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="4、修改返回数据"><a href="#4、修改返回数据" class="headerlink" title="4、修改返回数据"></a>4、修改返回数据</h3><p>​	这里以拷贝的形式返回数据，如果需要修改的话，需要对 DataItem 执行 before() 方法，这个在设置 XMAX 的值中体现了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 删除一个版本 只需要设置其 xmax 这样这个版本对每一个 xmax 后面的事务都不可见 等价于删除</span></span><br><span class="line"><span class="comment">* 设置 xmax 的值【设置为一个事务编号】</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> xid</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setXmax</span><span class="params">(<span class="type">long</span> xid)</span> &#123;</span><br><span class="line">    dataItem.before();			<span class="comment">//dataitem加锁</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">SubArray</span> <span class="variable">sa</span> <span class="operator">=</span> dataItem.data();</span><br><span class="line">        System.arraycopy(Parser.long2Byte(xid), <span class="number">0</span>, sa.raw, sa.start+OF_XMAX, <span class="number">8</span>);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        dataItem.after(xid);	<span class="comment">//生成对应事务日志</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h2><p>​	MyDB 支持的事务隔离程度是 RC【读提交】 为了解决脏读、RR 【可重复读】为了解决不可重复读。</p>
<h3 id="1、读已提交-Read-Committed"><a href="#1、读已提交-Read-Committed" class="headerlink" title="1、读已提交 Read Committed"></a>1、读已提交 Read Committed</h3><p>​	上面提到，如果一个记录的最新版本被加锁，当另一个事务想要修改或读取这条记录时，MYDB 就会返回一个较旧的版本的数据。这时就可以认为，最新的被加锁的版本，对于另一个事务来说，是不可见的。于是版本可见性的概念就诞生了。 版本的可见性与事务的隔离度是相关的。MYDB 支持的最低的事务隔离程度，是“读提交”（Read Committed），即事务在读取数据时, 只能读取已经提交事务产生的数据。保证最低的读提交的好处，第四章中已经说明（防止级联回滚与 commit 语义冲突）。 MYDB 实现读提交，为每个版本维护了两个变量，就是上面提到的 XMIN 和 XMAX</p>
<p>​	XMIN：创建该版本的事务编号 </p>
<p>​	XMAX：删除该版本的事务编号</p>
<p>​	XMIN 应当在版本创建时填写，而 XMAX 则在版本被删除，或者有新版本出现时填写。 XMAX 这个变量，也就解释了为什么 DM 层不提供删除操作，当想删除一个版本时，只需要设置其 XMAX，这样，这个版本对每一个 XMAX 之后的事务都是不可见的，也就等价于删除了。 如此，在读提交下，版本对事务的可见性逻辑如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(XMIN == Ti and                             <span class="comment">// 由Ti创建且</span></span><br><span class="line">    XMAX == NULL                            <span class="comment">// 还未被删除</span></span><br><span class="line">)</span><br><span class="line">or                                          <span class="comment">// 或</span></span><br><span class="line">(XMIN is commited and                       <span class="comment">// 由一个已提交的事务创建且</span></span><br><span class="line">    (XMAX == NULL or                        <span class="comment">// 尚未删除或</span></span><br><span class="line">    (XMAX != Ti and XMAX is not commited)   <span class="comment">// 由一个未提交的事务删除</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>​	若条件为 true，则版本对 Ti 可见。那么获取 Ti 适合的版本，只需要从最新版本开始，依次向前检查可见性，如果为 true，就可以直接返回。 以下方法判断某个记录对事务 t 是否可见：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 读提交 隔离级别下判断某个 entry 对事务 t 是否可见的判断</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> tm</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> t</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> e</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">readCommitted</span><span class="params">(TransactionManager tm, Transaction t, Entry e)</span>&#123;</span><br><span class="line">    <span class="comment">//获取事务id 和记录的 xmin 和 xmax</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">xid</span> <span class="operator">=</span> t.xid;</span><br><span class="line">    <span class="type">long</span> <span class="variable">xmin</span> <span class="operator">=</span> e.getXmin();</span><br><span class="line">    <span class="type">long</span> <span class="variable">xmax</span> <span class="operator">=</span> e.getXmax();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//若entry是xid创建的 并且 xmax 值为0 说明没有新版本的 entry 或者没有删除该 entry</span></span><br><span class="line">    <span class="keyword">if</span>(xmin == xid &amp;&amp; xmax == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(tm.isCommitted(xmin))&#123;      <span class="comment">//该 entry 已提交事务</span></span><br><span class="line">        <span class="keyword">if</span>(xmax == <span class="number">0</span>)&#123;             <span class="comment">//未修改则可见</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(xmax != xid)&#123;            <span class="comment">//若是 xid 之外的其他事务修改了 xmax 的值 删除了该 entry</span></span><br><span class="line">            <span class="keyword">if</span>(!tm.isCommitted(xmax))&#123;  <span class="comment">//但是没有提交 则依旧是可见的</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	这里的 Transaction 结构只提供了一个 XID。 </p>
<h3 id="2、可重复读-Repeatable-Read"><a href="#2、可重复读-Repeatable-Read" class="headerlink" title="2、可重复读  Repeatable Read"></a>2、可重复读  Repeatable Read</h3><p>​	读提交会导致的问题大家也都很清楚，八股也背了不少。那就是不可重复读和幻读。这里我们来解决不可重复读的问题。 </p>
<p>​	不可重复度，会导致一个事务在执行期间对同一个数据项的读取得到不同结果。如下面的结果，加入 X 初始值为 0：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">T1 begin</span><br><span class="line"><span class="title function_">R1</span><span class="params">(X)</span> <span class="comment">// T1 读得 0</span></span><br><span class="line">T2 begin</span><br><span class="line"><span class="title function_">U2</span><span class="params">(X)</span> <span class="comment">// 将 X 修改为 1</span></span><br><span class="line">T2 commit</span><br><span class="line"><span class="title function_">R1</span><span class="params">(X)</span> <span class="comment">// T1 读的 1</span></span><br></pre></td></tr></table></figure>

<p>​	可以看到，T1 两次读 X，读到的结果不一样。如果想要避免这个情况，就需要引入更严格的隔离级别，即可重复读（repeatable read）。 T1 在第二次读取的时候，读到了已经提交的 T2 修改的值，导致了这个问题。于是我们可以规定： :::primary 事务只能读取它开始时, 就已经结束的那些事务产生的数据版本 ::: 这条规定，增加于，事务需要忽略：</p>
<p>​	在本事务后开始的事务的数据; 本事务开始时还是 active 状态的事务的数据</p>
<p>​	对于第一条，只需要比较事务 ID，即可确定。而对于第二条，则需要在事务 Ti 开始时，记录下当前活跃的所有事务 SP(Ti)，如果记录的某个版本，XMIN 在 SP(Ti) 中，也应当对 Ti 不可见。</p>
<p>​	于是，可重复读的判断逻辑如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(XMIN == Ti and                 <span class="comment">// 由Ti创建且</span></span><br><span class="line"> (XMAX == NULL or               <span class="comment">// 尚未被删除</span></span><br><span class="line">))</span><br><span class="line">or                              <span class="comment">// 或</span></span><br><span class="line">(XMIN is commited and           <span class="comment">// 由一个已提交的事务创建且</span></span><br><span class="line"> XMIN &lt; XID and                 <span class="comment">// 这个事务小于Ti且</span></span><br><span class="line"> XMIN is not in <span class="title function_">SP</span><span class="params">(Ti)</span> and      <span class="comment">// 这个事务在Ti开始前提交且</span></span><br><span class="line"> (XMAX == NULL or               <span class="comment">// 尚未被删除或</span></span><br><span class="line">  (XMAX != Ti and               <span class="comment">// 由其他事务删除但是</span></span><br><span class="line">   (XMAX is not commited or     <span class="comment">// 这个事务尚未提交或</span></span><br><span class="line">XMAX &gt; Ti or                    <span class="comment">// 这个事务在Ti开始之后才开始或</span></span><br><span class="line">XMAX is in <span class="title function_">SP</span><span class="params">(Ti)</span>               <span class="comment">// 这个事务在Ti开始前还未提交</span></span><br><span class="line">))))</span><br></pre></td></tr></table></figure>

<p>​	于是，需要提供一个结构，来抽象一个事务，以保存快照数据：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Transaction</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">long</span> xid;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> level;		<span class="comment">//level 表示隔离级别</span></span><br><span class="line">	<span class="keyword">public</span> Map&lt;Long, Boolean&gt; snapshot;	  	<span class="comment">//快照中保存了所有还 active 【活跃】 的事务</span></span><br><span class="line">	<span class="keyword">public</span> Exception err;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">boolean</span> autoAborted;			<span class="comment">//自动撤销回滚判断</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">//方法中的 active 保存着所有活跃的事务</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Transaction <span class="title function_">newTransaction</span><span class="params">(<span class="type">long</span> xid, <span class="type">int</span> level, Map&lt;Long, Transaction&gt; active)</span> &#123;</span><br><span class="line">        <span class="type">Transaction</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Transaction</span>();</span><br><span class="line">        t.xid = xid;</span><br><span class="line">        t.level = level;</span><br><span class="line">        <span class="keyword">if</span>(level != <span class="number">0</span>) &#123;</span><br><span class="line">            t.snapshot = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(Long x : active.keySet()) &#123;		<span class="comment">//将还活跃的事务加入哈希表 value 为 true</span></span><br><span class="line">                t.snapshot.put(x, <span class="literal">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 判断一个事务是否在快照数据内</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> xid</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isInSnapshot</span><span class="params">(<span class="type">long</span> xid)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(xid == TransactionManagerImpl.SUPER_ID)&#123;   <span class="comment">//如果该事务是超级事务 则一定不在快照中 不活跃</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> snapshot.containsKey(xid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	构造方法中的 active，保存着当前所有 active 的事务。于是，可重复读的隔离级别下，一个版本是否对事务可见的判断如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 可重复读 隔离级别下 某个 entry 对事务 t 是否可见的判断</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> tm</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> t</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> e</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">repeatableRead</span><span class="params">(TransactionManager tm, Transaction t, Entry e)</span>&#123;</span><br><span class="line">    <span class="comment">//获取事务id 和记录的 xmin 和 xmax</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">xid</span> <span class="operator">=</span> t.xid;</span><br><span class="line">    <span class="type">long</span> <span class="variable">xmin</span> <span class="operator">=</span> e.getXmin();</span><br><span class="line">    <span class="type">long</span> <span class="variable">xmax</span> <span class="operator">=</span> e.getXmax();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//若entry是xid创建的 并且 xmax 值为0 说明没有新版本的 entry 或者没有删除该 entry</span></span><br><span class="line">    <span class="keyword">if</span>(xmin == xid &amp;&amp; xmax == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*如果xmin </span></span><br><span class="line"><span class="comment">      已提交创建&amp;&amp;这个事务小于当前事务&amp;&amp;这个事务没在快照数据中【该事务在当前事务开始前就提交了，不活跃了】</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span>(tm.isCommitted(xmin) &amp;&amp; xmin &lt; xid &amp;&amp; !t.isInSnapshot(xmin))&#123;</span><br><span class="line">        <span class="keyword">if</span>(xmax == <span class="number">0</span>)&#123;  <span class="comment">//并且 没有新版本的 entry 或者没有删除该 entry</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(xmax != xid)&#123;  <span class="comment">//或者 这个 entry 被其他事务删除了</span></span><br><span class="line">            <span class="comment">/*并且</span></span><br><span class="line"><span class="comment">            	1、删除他的事务尚未提交</span></span><br><span class="line"><span class="comment">            	2、删除他的事务在当前事务开始之后才开始、 </span></span><br><span class="line"><span class="comment">            	3、这个事务在快照数据中【该事务在当前事务开始前还没提交，属于活跃事务】</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">if</span>(!tm.isCommitted(xmax) || xmax &gt; xid || t.isInSnapshot(xmax))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="死锁检测与-VM-的实现"><a href="#死锁检测与-VM-的实现" class="headerlink" title="死锁检测与 VM 的实现"></a>死锁检测与 VM 的实现</h1><h2 id="版本跳跃问题"><a href="#版本跳跃问题" class="headerlink" title="版本跳跃问题"></a>版本跳跃问题</h2><p>​	说到版本跳跃之前，MVCC 的实现，使得 MYDB 在撤销或是回滚事务很简单：只需要将这个事务标记为 aborted 即可。根据之前提到的可见性，每个事务都只能看到其他 committed 的事务所产生的数据，一个 aborted 事务产生的数据，就不会对其他事务产生任何影响了，也就相当于，这个事务不曾存在过。 </p>
<h3 id="1、版本跳跃问题举例"><a href="#1、版本跳跃问题举例" class="headerlink" title="1、版本跳跃问题举例"></a>1、版本跳跃问题举例</h3><p>​	版本跳跃问题，考虑如下的情况，假设 X 最初只有 x0 版本，T1 和 T2 都是可重复读的隔离级别：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">T1 begin</span><br><span class="line">T2 begin</span><br><span class="line">R1(X) // T1读取x0</span><br><span class="line">R2(X) // T2读取x0</span><br><span class="line">U1(X) // T1将X更新到x1</span><br><span class="line">T1 commit</span><br><span class="line">U2(X) // T2将X更新到x2</span><br><span class="line">T2 commit</span><br></pre></td></tr></table></figure>

<p>​	这种情况实际运行起来是没问题的，但是逻辑上不太正确。T1 将 X 从 x0 更新为了 x1，这是没错的。但是 T2 则是将 X 从 x0 更新成了 x2，跳过了 x1 版本。 </p>
<p>​	读提交是允许版本跳跃的，而可重复读则是不允许版本跳跃的。</p>
<h3 id="2、版本跳跃检查解决"><a href="#2、版本跳跃检查解决" class="headerlink" title="2、版本跳跃检查解决"></a>2、版本跳跃检查解决</h3><p>​	解决版本跳跃的思路也很简单：如果 Ti 需要修改 X，而 X 已经被 Ti 不可见的事务 Tj 修改了，那么要求 Ti 回滚。 上一节中就总结了，Ti 不可见的 Tj，有两种情况：</p>
<ol>
<li>XID(Tj) &gt; XID(Ti)</li>
<li>Tj in SP(Ti)</li>
</ol>
<p>​	于是版本跳跃的检查也就很简单了，取出要修改的数据 X 的最新提交版本，并检查该最新版本的创建者对当前事务是否可见：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 版本跳跃检查</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> tm</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> t</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> e</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isVersionSkip</span><span class="params">(TransactionManager tm, Transaction t, Entry e)</span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">xmax</span> <span class="operator">=</span> e.getXmax();    <span class="comment">//获取要修改 entry 的最新提交版本 xmax</span></span><br><span class="line">    <span class="keyword">if</span>(t.level == <span class="number">0</span>)&#123;    <span class="comment">//如果隔离级别为 读提交 则返回false 【读提交这种隔离级别是支持版本跳跃的】</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">/*检查当前事务的最新版本 并且 【最新版本 在当前事务开始之后才开始 或者 这个事务在快照数据中【该事		  务在当前事务开始前还没提交，属于活跃事务】】</span></span><br><span class="line"><span class="comment">          则存在版本跳跃*/</span></span><br><span class="line">        <span class="keyword">return</span> tm.isCommitted(xmax) &amp;&amp; (xmax &gt; t.xid || t.isInSnapshot(xmax));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="死锁检测"><a href="#死锁检测" class="headerlink" title="死锁检测"></a>死锁检测</h2><p>​	维护了一个依赖等待图 以进行死锁检测</p>
<p>​	将线程的等待释放锁关系抽象成有向边</p>
<p>​	eg：Tj在等待Ti，就可以表示成 Tj –&gt; Ti  不同的有向边形成一个图</p>
<p>​	检测死锁 即检测这张图中是否存在环</p>
<p>​	每次出现等待情况 就向图中加入一条边 并进行死锁检测 【如果检测到死锁 就撤销这条边 不允许添加 并且撤销事务】</p>
<h3 id="1、等待关系抽象为图的图结构"><a href="#1、等待关系抽象为图的图结构" class="headerlink" title="1、等待关系抽象为图的图结构"></a>1、等待关系抽象为图的图结构</h3><p>​	MYDB 使用一个 LockTable 对象，在内存中维护这张图。维护结构如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LockTable</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Map&lt;Long, List&lt;Long&gt;&gt; x2u;  <span class="comment">// 某个XID已经获得的资源的UID列表</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Long, Long&gt; u2x;        <span class="comment">// UID被某个XID持有</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Long, List&lt;Long&gt;&gt; wait; <span class="comment">// 正在等待UID的XID列表</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Long, Lock&gt; waitLock;   <span class="comment">// 正在等待资源的XID的锁</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Long, Long&gt; waitU;      <span class="comment">// XID正在等待的UID</span></span><br><span class="line">    <span class="keyword">private</span> Lock lock;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、遇到等待需检测死锁"><a href="#2、遇到等待需检测死锁" class="headerlink" title="2、遇到等待需检测死锁"></a>2、遇到等待需检测死锁</h3><p>​	在每次出现等待的情况时，就尝试向图中增加一条边，并进行死锁检测。如果检测到死锁，就撤销这条边，不允许添加，并撤销该事务。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 向图中添加一条边</span></span><br><span class="line"><span class="comment">* 不需要等待【边已存在】则返回null 否则返回锁对象</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> xid</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> uid</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Lock <span class="title function_">add</span><span class="params">(<span class="type">long</span> xid, <span class="type">long</span> uid)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(isInList(x2u, xid, uid))&#123;  <span class="comment">//xid 已经获得 uid 资源，说明边已存在 返回null</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!u2x.containsKey(uid))&#123;      <span class="comment">//如果 该 uid 资源没有被某个 xid 持有</span></span><br><span class="line">            u2x.put(uid, xid);          <span class="comment">//让 uid 被 xid 持有</span></span><br><span class="line">            putIntoList(x2u, xid, uid); <span class="comment">//并且 将 xid 获得 uid 资源，【加入 x2u 表】</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        waitU.put(xid, uid);            <span class="comment">//以上两个 if 不成立，xid 正在等待 uid，加入waitU表</span></span><br><span class="line">        putIntoList(wait, xid, uid);    <span class="comment">//加入正在等待 uid 资源的 xid 列表</span></span><br><span class="line">        <span class="keyword">if</span>(hasDeadLock())&#123;              <span class="comment">//如果已经发生死锁</span></span><br><span class="line">            waitU.remove(xid);          <span class="comment">//撤销等待的xid</span></span><br><span class="line">            removeFromList(wait, uid, xid); <span class="comment">//将wait 中 uid 对应的 xid 列表，列表中存在的 xid 将其删除</span></span><br><span class="line">            <span class="keyword">throw</span> Error.DeadlockException;  <span class="comment">//报错死锁了</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Lock</span> <span class="variable">l</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">        l.lock();       <span class="comment">//设置一个上了锁的 lock 对象</span></span><br><span class="line">        waitLock.put(xid, l);   <span class="comment">//将这个xid 资源加入表  正在等待 xid 资源的 锁</span></span><br><span class="line">        <span class="keyword">return</span> l;       <span class="comment">//返回该上了锁的对象</span></span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3、继续等待"><a href="#3、继续等待" class="headerlink" title="3、继续等待"></a>3、继续等待</h3><p>​	调用 add，如果需要等待的话，会返回一个上了锁的 Lock 对象。调用方在获取到该对象时，需要尝试获取该对象的锁，由此实现阻塞线程的目的，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Lock</span> <span class="variable">l</span> <span class="operator">=</span> lt.add(xid, uid);</span><br><span class="line"><span class="keyword">if</span>(l != <span class="literal">null</span>) &#123;</span><br><span class="line">    l.lock();   <span class="comment">// 阻塞在这一步</span></span><br><span class="line">    l.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4、通过查看图中是否有环来检测死锁"><a href="#4、通过查看图中是否有环来检测死锁" class="headerlink" title="4、通过查看图中是否有环来检测死锁"></a>4、通过查看图中是否有环来检测死锁</h3><p>​	多个等待关系可以抽象为有环的图，查找图中是否有环，采用深搜，只是需要注意这个图不一定是连通图。思路就是为每个节点设置一个访问戳，都初始化为 -1，随后遍历所有节点，以每个非 -1 的节点作为根进行深搜，并将深搜该连通图中遇到的所有节点都设置为同一个数字，不同的连通图数字不同。这样，如果在遍历某个图时，遇到了之前遍历过的节点，说明出现了环。 实现很简单：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断是否发生死锁</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">hasDeadLock</span><span class="params">()</span> &#123;</span><br><span class="line">    xidStamp = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    stamp = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">long</span> xid : x2u.keySet()) &#123;			<span class="comment">//遍历 x2u 中的 xid 列表</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">s</span> <span class="operator">=</span> xidStamp.get(xid);		<span class="comment">//获得访问戳表中 xid 对应的访问戳</span></span><br><span class="line">        <span class="keyword">if</span>(s != <span class="literal">null</span> &amp;&amp; s &gt; <span class="number">0</span>) &#123;			<span class="comment">//如果访问戳非空 并且大于0</span></span><br><span class="line">            <span class="keyword">continue</span>;						<span class="comment">//访问戳不变</span></span><br><span class="line">        &#125;</span><br><span class="line">        stamp ++;							<span class="comment">//将访问戳加1</span></span><br><span class="line">        <span class="keyword">if</span>(dfs(xid)) &#123;						<span class="comment">//以新的节点作为根节点进行dfs</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;					<span class="comment">//如果遍历到了之前遍历过的点 说明出现了环</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">dfs</span><span class="params">(<span class="type">long</span> xid)</span> &#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">stp</span> <span class="operator">=</span> xidStamp.get(xid);		<span class="comment">//获得当前 xid 对应的访问戳</span></span><br><span class="line">    <span class="keyword">if</span>(stp != <span class="literal">null</span> &amp;&amp; stp == stamp) &#123;		<span class="comment">//如果访问戳非空 并且没有变化</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;						<span class="comment">//说明出现了环</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(stp != <span class="literal">null</span> &amp;&amp; stp &lt; stamp) &#123;		<span class="comment">//如果访问戳非空并且以前出现过</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;						<span class="comment">//没有环</span></span><br><span class="line">    &#125;</span><br><span class="line">    xidStamp.put(xid, stamp);				<span class="comment">//将xid 和 访问戳 加入表</span></span><br><span class="line"> </span><br><span class="line">    <span class="type">Long</span> <span class="variable">uid</span> <span class="operator">=</span> waitU.get(xid);				<span class="comment">//获得当前 xid 正在等待的 uid资源</span></span><br><span class="line">    <span class="keyword">if</span>(uid == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;			<span class="comment">//如果没有资源 则没有死锁</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">x</span> <span class="operator">=</span> u2x.get(uid);					<span class="comment">//如果该资源被某个 xid 已经持有</span></span><br><span class="line">    <span class="keyword">assert</span> x != <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> dfs(x);							<span class="comment">//以新的 uid 作为根节点 进行dfs</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5、释放锁的方法"><a href="#5、释放锁的方法" class="headerlink" title="5、释放锁的方法"></a>5、释放锁的方法</h3><p>​	在一个事务 commit 或者 abort 时，就可以释放所有它持有的锁，并将自身从等待图中删除。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 在一个事务 commit 或者 abort 时 需要释放它持有的锁 并将自身从等待图删除</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> xid</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(<span class="type">long</span> xid)</span> &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        List&lt;Long&gt; l = x2u.get(xid);		<span class="comment">//获得 xid 持有的对应的 uid 列表</span></span><br><span class="line">        <span class="keyword">if</span>(l != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span>(l.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">Long</span> <span class="variable">uid</span> <span class="operator">=</span> l.remove(<span class="number">0</span>);		<span class="comment">//while循环释放了这个线程所有持有资源的锁</span></span><br><span class="line">                selectNewXID(uid);			<span class="comment">//这些资源要被等待的线程获取</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//从剩余几个表中释放当前 xid 对应的所有资源</span></span><br><span class="line">        waitU.remove(xid);</span><br><span class="line">        x2u.remove(xid);</span><br><span class="line">        waitLock.remove(xid);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	while 循环释放掉了这个线程所有持有的资源的锁，这些资源可以被等待的线程所获取：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 从等待队列中选择一个 xid 来占用当前 uid 资源</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> uid</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">selectNewXid</span><span class="params">(<span class="type">long</span> uid)</span>&#123;</span><br><span class="line">    u2x.remove(uid);  				<span class="comment">//删除uid 对应的持有他的 xid</span></span><br><span class="line">    List&lt;Long&gt; l = wait.get(uid);   <span class="comment">//从等待列表获取等待当前uid的 xid的list集合</span></span><br><span class="line">    <span class="keyword">if</span>(l == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">assert</span> l.size() &gt; <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//while 循环释放掉了这个线程所有持有的资源的锁，这些资源可以被等待的线程所获取</span></span><br><span class="line">    <span class="keyword">while</span>(l.size() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">xid</span> <span class="operator">=</span> l.remove(<span class="number">0</span>);  			<span class="comment">//xid表 移除所有的xid 并操作移除的xid</span></span><br><span class="line">        <span class="keyword">if</span>(!waitLock.containsKey(xid))&#123;     <span class="comment">//如果当前xid 没有在等待资源 没有上锁 跳过</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            u2x.put(uid, xid);  			<span class="comment">//列表中选择的新的 xid 占用 uid 资源</span></span><br><span class="line">            <span class="type">Lock</span> <span class="variable">lo</span> <span class="operator">=</span> waitLock.remove(xid); <span class="comment">//移除并获取等待资源的xid 的锁</span></span><br><span class="line">            waitU.remove(xid);      		<span class="comment">//移除正在等待 uid 的 xid</span></span><br><span class="line">            lo.unlock();            		<span class="comment">//解锁</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果等待列表没有等待的 xid</span></span><br><span class="line">    <span class="keyword">if</span>(l.size() == <span class="number">0</span>)&#123;</span><br><span class="line">        wait.remove(uid);   <span class="comment">//将 uid 对应的 key-value 直接删除</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	从 List 开头开始尝试解锁，还是个公平锁。解锁时，将该 Lock 对象 unlock 即可，这样业务线程就获取到了锁，就可以继续执行了。 </p>
<h2 id="VM-的整合实现"><a href="#VM-的整合实现" class="headerlink" title="VM 的整合实现"></a>VM 的整合实现</h2><h3 id="1、VM-接口参数和基本方法的实现"><a href="#1、VM-接口参数和基本方法的实现" class="headerlink" title="1、VM 接口参数和基本方法的实现"></a>1、VM 接口参数和基本方法的实现</h3><p>​	VM 层通过 Version Manager 接口，向上层提供功能，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">VersionManager</span> &#123;</span><br><span class="line">    <span class="type">byte</span>[] read(<span class="type">long</span> xid, <span class="type">long</span> uid) <span class="keyword">throws</span> Exception;</span><br><span class="line">    <span class="type">long</span> <span class="title function_">insert</span><span class="params">(<span class="type">long</span> xid, <span class="type">byte</span>[] data)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">delete</span><span class="params">(<span class="type">long</span> xid, <span class="type">long</span> uid)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line"> </span><br><span class="line">    <span class="type">long</span> <span class="title function_">begin</span><span class="params">(<span class="type">int</span> level)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">commit</span><span class="params">(<span class="type">long</span> xid)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">abort</span><span class="params">(<span class="type">long</span> xid)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取缓存</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> Entry <span class="title function_">getForCache</span><span class="params">(<span class="type">long</span> uid)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">Entry</span> <span class="variable">entry</span> <span class="operator">=</span> Entry.loadEntry(<span class="built_in">this</span>, uid);</span><br><span class="line">    <span class="keyword">if</span>(entry == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> Error.NullEntryException;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> entry;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 释放缓存</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">releaseForCache</span><span class="params">(Entry entry)</span> &#123;</span><br><span class="line">    entry.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	同时，VM 的实现类还被设计为 Entry 的缓存，需要继承 AbstractCache。需要实现的获取到缓存和从缓存释放的方法。</p>
<h3 id="2、begin-commit-internAbort-方法对事务进行操作"><a href="#2、begin-commit-internAbort-方法对事务进行操作" class="headerlink" title="2、begin();commit();internAbort();方法对事务进行操作"></a>2、begin();commit();internAbort();方法对事务进行操作</h3><p>​	begin() 开启一个事务，并初始化事务的结构，将其存放在 activeTransaction 中，用于检查和快照使用。</p>
<p>​	commit() 方法提交一个事务，主要就是 free 掉相关的结构，并且释放持有的锁，并修改 TM 状态。</p>
<p>​	abort() 事务的方法则有两种，手动和自动。手动指的是调用 abort() 方法，而自动，则是在事务被检测出出现死锁时，会自动撤销回滚事务；或者出现版本跳跃时，也会自动回滚。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 开启一个事务 并初始化事务的结构 将其存放在 activeTransaction 中 用于检查和快照使用</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> level 隔离级别</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">begin</span><span class="params">(<span class="type">int</span> level)</span> &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">xid</span> <span class="operator">=</span> tm.begin();  <span class="comment">//开启一个新事务</span></span><br><span class="line">        <span class="comment">//将事务id 隔离级别 包装成一个 Transaction 对象</span></span><br><span class="line">        <span class="type">Transaction</span> <span class="variable">t</span> <span class="operator">=</span> Transaction.newTransaction(xid, level, activeTransaction);  </span><br><span class="line">        activeTransaction.put(xid, t);  <span class="comment">//将其存放在 activeTransaction 中 用于检查和快照使用</span></span><br><span class="line">        <span class="keyword">return</span> xid; <span class="comment">//返回事务 xid</span></span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 提交一个事务 free 掉相关的结构 释放持有的锁 修改 TM 的状态</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> xid</span></span><br><span class="line"><span class="comment">* <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">commit</span><span class="params">(<span class="type">long</span> xid)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="type">Transaction</span> <span class="variable">t</span> <span class="operator">=</span> activeTransaction.get(xid);		<span class="comment">//获得一个Transaction 对象</span></span><br><span class="line">    lock.unlock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(t.err != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> t.err;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(NullPointerException n) &#123;</span><br><span class="line">        System.out.println(xid);</span><br><span class="line">        System.out.println(activeTransaction.keySet());</span><br><span class="line">        Panic.panic(n);</span><br><span class="line">    &#125;</span><br><span class="line">    lock.lock();</span><br><span class="line">    activeTransaction.remove(xid);		<span class="comment">// 移除xid 对应的 key-value</span></span><br><span class="line">    lock.unlock();</span><br><span class="line">    lt.remove(xid);			<span class="comment">//释放其持有的锁</span></span><br><span class="line">    tm.commit(xid);			<span class="comment">//将 TM 的状态修改 提交 xid 对应的事务状态为 FIELD_TRAN_COMMITTED</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 撤销和回滚 xid 事务</span></span><br><span class="line"><span class="comment">* 分为自动回滚和手动回滚  传入参数 false/true</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> xid</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">internAbort</span><span class="params">(<span class="type">long</span> xid, <span class="type">boolean</span> autoAborted)</span> &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="type">Transaction</span> <span class="variable">t</span> <span class="operator">=</span> activeTransaction.get(xid);		<span class="comment">//获得一个Transaction 对象</span></span><br><span class="line">    <span class="keyword">if</span>(!autoAborted) &#123;								<span class="comment">//如果autoAborted 为false 则为手动提交</span></span><br><span class="line">        activeTransaction.remove(xid);  <span class="comment">//直接移除activeTransaction中 xid 对应的 key—value</span></span><br><span class="line">    &#125;</span><br><span class="line">    lock.unlock();</span><br><span class="line">    <span class="keyword">if</span>(t.autoAborted) <span class="keyword">return</span>;  <span class="comment">//如果自动撤销 在检测出死锁时 会自动撤销回滚事务  因此不需要额外操作</span></span><br><span class="line">    lt.remove(xid);			   <span class="comment">//释放其持有的锁</span></span><br><span class="line">    tm.abort(xid);			   <span class="comment">//将 TM 的状态修改 提交 xid 对应的事务状态为 FIELD_TRAN_ABORTED</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3、read-insert-delete-方法对数据进行操作"><a href="#3、read-insert-delete-方法对数据进行操作" class="headerlink" title="3、read();insert();delete(); 方法对数据进行操作"></a>3、read();insert();delete(); 方法对数据进行操作</h3><p>​	read()：方法读取一个 entry，注意判断下可见性即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 读取一个 entry 记录 【注意判断可见性】</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> xid</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> uid</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">* <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">byte</span>[] read(<span class="type">long</span> xid, <span class="type">long</span> uid) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="type">Transaction</span> <span class="variable">t</span> <span class="operator">=</span> activeTransaction.get(xid);		<span class="comment">//获得一个Transaction 对象</span></span><br><span class="line">    lock.unlock();</span><br><span class="line">    <span class="keyword">if</span>(t.err != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> t.err;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Entry</span> <span class="variable">entry</span> <span class="operator">=</span> <span class="built_in">super</span>.get(uid);		<span class="comment">//从缓存中获取 entry 记录</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(Visibility.isVisible(tm, t, entry)) &#123;		<span class="comment">//进行事务隔离级别检查</span></span><br><span class="line">            <span class="keyword">return</span> entry.data();						<span class="comment">//返回其能够读取的记录版本</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        entry.release();				<span class="comment">//释放缓存</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	insert()：则是将数据包裹成 Entry，无脑交给 DM 插入即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 将数据包裹成 Entry 交给 TM 插入</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> xid</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> data</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">* <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">insert</span><span class="params">(<span class="type">long</span> xid, <span class="type">byte</span>[] data)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="type">Transaction</span> <span class="variable">t</span> <span class="operator">=</span> activeTransaction.get(xid); <span class="comment">//获得一个Transaction 对象</span></span><br><span class="line">    lock.unlock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(t.err != <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> t.err;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">byte</span>[] raw = Entry.wrapEntryRaw(xid, data);  <span class="comment">//将 data 转换成 Entry 对象 【byte数组】</span></span><br><span class="line">    <span class="keyword">return</span> dm.insert(xid, raw);                  <span class="comment">//调用 dm 中的 insert 方法将 entry 插入页面</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	delete()：方法看起来略为复杂：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除一条 entry</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> xid</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> uid</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">delete</span><span class="params">(<span class="type">long</span> xid, <span class="type">long</span> uid)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="type">Transaction</span> <span class="variable">t</span> <span class="operator">=</span> activeTransaction.get(xid);		<span class="comment">//获得一个Transaction 对象</span></span><br><span class="line">    lock.unlock();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>(t.err != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> t.err;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Entry</span> <span class="variable">entry</span> <span class="operator">=</span> <span class="built_in">super</span>.get(uid);			<span class="comment">//从缓存中获取 entry 记录</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(!Visibility.isVisible(tm, t, entry)) &#123;	<span class="comment">//进行事务隔离级别检查 不可见则返回false</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Lock</span> <span class="variable">l</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            l = lt.add(xid, uid);				<span class="comment">//获取资源的锁</span></span><br><span class="line">        &#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">            t.err = Error.ConcurrentUpdateException;	<span class="comment">//出现异常则</span></span><br><span class="line">            internAbort(xid, <span class="literal">true</span>);						<span class="comment">//手动回滚事务</span></span><br><span class="line">            t.autoAborted = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">throw</span> t.err;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l != <span class="literal">null</span>) &#123;</span><br><span class="line">            l.lock();</span><br><span class="line">            l.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(entry.getXmax() == xid) &#123;   <span class="comment">//如果其最新版本是 xid 事务 不用删除 已经对后面事务不可见了</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(Visibility.isVersionSkip(tm, t, entry)) &#123;	<span class="comment">//进行版本跳跃检查</span></span><br><span class="line">            t.err = Error.ConcurrentUpdateException;</span><br><span class="line">            internAbort(xid, <span class="literal">true</span>);		<span class="comment">//存在版本跳跃 则手动回滚</span></span><br><span class="line">            t.autoAborted = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">throw</span> t.err;</span><br><span class="line">        &#125;</span><br><span class="line">        entry.setXmax(xid);	  <span class="comment">//将该条记录的 xmax 值设置为 当前 xid 表明之后的事务无法看到该条记录</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;			<span class="comment">//删除完成</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        entry.release();		<span class="comment">//释放缓存</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	实际上主要是前置的三件事：一是可见性判断，二是获取资源的锁，三是版本跳跃判断。删除的操作只有一个设置 XMAX。</p>
<h1 id="索引管理IM"><a href="#索引管理IM" class="headerlink" title="索引管理IM"></a>索引管理IM</h1><p>​	IM，即 Index Manager，索引管理器，为 MYDB 提供了基于 B+ 树的聚簇索引。目前 MYDB 只支持基于索引查找数据，不支持全表扫描。在依赖关系图中可以看到，IM 直接基于 DM，而没有基于 VM。索引的数据被直接插入数据库文件中，而不需要经过版本管理。 </p>
<h2 id="二叉树索引"><a href="#二叉树索引" class="headerlink" title="二叉树索引"></a>二叉树索引</h2><h3 id="1、二叉树结构"><a href="#1、二叉树结构" class="headerlink" title="1、二叉树结构"></a>1、二叉树结构</h3><p>​	二叉树由一个个 Node 组成，每个 Node 都存储在一条 DataItem 中。Node结构如下：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[LeafFlag]</span><span class="selector-attr">[KeyNumber]</span><span class="selector-attr">[SiblingUid]</span></span><br></pre></td></tr></table></figure>

<p>​	其中 LeafFlag 标记了该节点是否是个叶子节点；KeyNumber 为该节点中 key 的个数；SiblingUid 是其兄弟节点存储在 DM 中的 UID。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[Son0]</span><span class="selector-attr">[Key0]</span><span class="selector-attr">[Son1]</span><span class="selector-attr">[Key1]</span>...<span class="selector-attr">[SonN]</span><span class="selector-attr">[KeyN]</span></span><br></pre></td></tr></table></figure>

<p>​	后续是穿插的子节点（SonN）和 KeyN。最后的一个 KeyN 始终为 MAX_VALUE，以此方便查找。 Node 类持有了其 B+ 树结构的引用，DataItem 的引用和 SubArray 的引用，用于方便快速修改数据和释放数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    BPlusTree tree;			<span class="comment">//b+树结构引用</span></span><br><span class="line">    <span class="comment">//dataitem 和 subarray 的引用用于方便和快速修改和释放数据</span></span><br><span class="line">    DataItem dataItem;</span><br><span class="line">    SubArray raw;</span><br><span class="line">    <span class="type">long</span> uid;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、根节点的结构"><a href="#2、根节点的结构" class="headerlink" title="2、根节点的结构"></a>2、根节点的结构</h3><p>​	于是生成一个根节点的数据可以写成如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 生成一个根节点的数据</span></span><br><span class="line"><span class="comment"> * 初始两个子节点为 left 和 right，初始键值为 key     </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> left</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> right</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">byte</span>[] newRootRaw(<span class="type">long</span> left, <span class="type">long</span> right, <span class="type">long</span> key)  &#123;</span><br><span class="line">    <span class="type">SubArray</span> <span class="variable">raw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SubArray</span>(<span class="keyword">new</span> <span class="title class_">byte</span>[NODE_SIZE], <span class="number">0</span>, NODE_SIZE);</span><br><span class="line">    setRawIsLeaf(raw, <span class="literal">false</span>);		<span class="comment">//设置当前节点为非叶子节点</span></span><br><span class="line">    setRawNoKeys(raw, <span class="number">2</span>);			<span class="comment">//设置节点中key的数量为2</span></span><br><span class="line">    setRawSibling(raw, <span class="number">0</span>);			<span class="comment">//设置其兄弟节点的uid【无兄弟节点】</span></span><br><span class="line">    setRawKthSon(raw, left, <span class="number">0</span>);		<span class="comment">//设置其第一个子节点为left</span></span><br><span class="line">    setRawKthKey(raw, key, <span class="number">0</span>);		<span class="comment">//设置其第一个子节点对应的key为key</span></span><br><span class="line">    setRawKthSon(raw, right, <span class="number">1</span>);	<span class="comment">//设置其第二个子节点为right</span></span><br><span class="line">    setRawKthKey(raw, Long.MAX_VALUE, <span class="number">1</span>);<span class="comment">//设置其第二个子节点对应的key【最后的key】为maxvalue</span></span><br><span class="line">    <span class="keyword">return</span> raw.raw;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	该根节点的初始两个子节点为 left 和 right, 初始键值为 key。 类似的，生成一个空的根节点数据：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 生成一个空的根节点数据 返回</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">byte</span>[] newNilRootRaw()  &#123;</span><br><span class="line">    <span class="type">SubArray</span> <span class="variable">raw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SubArray</span>(<span class="keyword">new</span> <span class="title class_">byte</span>[NODE_SIZE], <span class="number">0</span>, NODE_SIZE);	<span class="comment">//建立共享数组的数据结构</span></span><br><span class="line">    setRawIsLeaf(raw, <span class="literal">true</span>);	<span class="comment">//设置为树的叶子节点</span></span><br><span class="line">    setRawNoKeys(raw, <span class="number">0</span>);		<span class="comment">//设置其节点中key的数量为0</span></span><br><span class="line">    setRawSibling(raw, <span class="number">0</span>);		<span class="comment">//设置其无兄弟节点</span></span><br><span class="line">    <span class="keyword">return</span> raw.raw;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3、searchNex-leafSearchRange-方法用于辅助-B-树做插入和搜索操作"><a href="#3、searchNex-leafSearchRange-方法用于辅助-B-树做插入和搜索操作" class="headerlink" title="3、searchNex(); leafSearchRange(); 方法用于辅助 B+ 树做插入和搜索操作"></a>3、searchNex(); leafSearchRange(); 方法用于辅助 B+ 树做插入和搜索操作</h3><p>​	Node 类有两个方法，用于辅助 B+ 树做插入和搜索操作，分别是 searchNext 方法和 leafSearchRange 方法。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 寻找对应 Key 的 Uid，如果找不到则返回兄弟节点的 Uid</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> SearchNextRes <span class="title function_">searchNext</span><span class="params">(<span class="type">long</span> key)</span> &#123;</span><br><span class="line">    dataItem.rLock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">SearchNextRes</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchNextRes</span>();    <span class="comment">//查找结果【key的uid， key的兄弟节点uid】</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">noKeys</span> <span class="operator">=</span> getRawNoKeys(raw);     <span class="comment">//获取节点中key的数量</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; noKeys; i ++) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">ik</span> <span class="operator">=</span> getRawKthKey(raw, i);     <span class="comment">//遍历每一个key</span></span><br><span class="line">            <span class="keyword">if</span>(key &lt; ik) &#123;</span><br><span class="line">                res.uid = getRawKthSon(raw, i);     <span class="comment">//按顺序搜索 放在小于某节点之前</span></span><br><span class="line">                res.siblingUid = <span class="number">0</span>;     <span class="comment">//搜索到了 设置兄弟节点为0</span></span><br><span class="line">                <span class="keyword">return</span> res;         <span class="comment">//返回结果</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//没有搜索到 uid 为0，并且将兄弟节点赋予下一个 返回兄弟节点的 uid</span></span><br><span class="line">        res.uid = <span class="number">0</span>;</span><br><span class="line">        res.siblingUid = getRawSibling(raw);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        dataItem.rUnLock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	leafSearchRange 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在当前节点进行范围查找，范围是【leftKey，rightKey】</span></span><br><span class="line"><span class="comment"> * 约定 rightKey大于等于该节点的最大的 Key，同时返回兄弟节点的 Uid</span></span><br><span class="line"><span class="comment"> * 用于继续搜索下一个节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> leftKey</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> rightKey</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> LeafSearchRangeRes <span class="title function_">leafSearchRange</span><span class="params">(<span class="type">long</span> leftKey, <span class="type">long</span> rightKey)</span> &#123;</span><br><span class="line">    dataItem.rLock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">noKeys</span> <span class="operator">=</span> getRawNoKeys(raw);     <span class="comment">//获取当前节点 key 的数量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">kth</span> <span class="operator">=</span> <span class="number">0</span>;        <span class="comment">//第0个子节点</span></span><br><span class="line">        <span class="keyword">while</span>(kth &lt; noKeys) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">ik</span> <span class="operator">=</span> getRawKthKey(raw, kth);   <span class="comment">//获取 第 kth 个子节点 对应的 key</span></span><br><span class="line">            <span class="keyword">if</span>(ik &gt;= leftKey) &#123;     <span class="comment">//大于等于左侧的key break</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            kth ++;     <span class="comment">//小于等于左侧 key 则继续往右搜索，直到大于等于左侧</span></span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Long&gt; uids = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(kth &lt; noKeys) &#123;</span><br><span class="line">           <span class="type">long</span> <span class="variable">ik</span> <span class="operator">=</span> getRawKthKey(raw, kth);       <span class="comment">//获取 第 kth 个子节点 对应的 key</span></span><br><span class="line">           <span class="keyword">if</span>(ik &lt;= rightKey) &#123;        <span class="comment">//小于等于右侧 key 时</span></span><br><span class="line">                uids.add(getRawKthSon(raw, kth));   <span class="comment">//加入 uids 集合</span></span><br><span class="line">                kth ++; <span class="comment">//继续搜索</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;      <span class="comment">//直到大于 rightkey break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">siblingUid</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(kth == noKeys) &#123;</span><br><span class="line">            siblingUid = getRawSibling(raw);    <span class="comment">//当搜索完所有节点时 获得其兄弟节点的 uid</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">LeafSearchRangeRes</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LeafSearchRangeRes</span>();  <span class="comment">//存入搜索结果对象</span></span><br><span class="line">        res.uids = uids;</span><br><span class="line">        res.siblingUid = siblingUid;</span><br><span class="line">        <span class="keyword">return</span> res;     <span class="comment">//返回</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> </span><br><span class="line">        dataItem.rUnLock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4、B-树的创建和一些基本操作"><a href="#4、B-树的创建和一些基本操作" class="headerlink" title="4、B+ 树的创建和一些基本操作"></a>4、B+ 树的创建和一些基本操作</h3><p>​	由于 B+ 树在插入删除时，会动态调整，根节点不是固定节点，于是设置一个 bootDataItem，该 DataItem 中存储了根节点的 UID。可以注意到，IM 在操作 DM 时，使用的事务都是 SUPER_XID。</p>
<p>​	首先创建一颗b+树：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * CreateBPlusTree 创建一棵B+树, 并返回其bootUID.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> dm</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">create</span><span class="params">(DataManager dm)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    <span class="type">byte</span>[] rawRoot = Node.newNilRootRaw();      <span class="comment">//生成一个空的根节点数据 然后返回根节点结构</span></span><br><span class="line">    <span class="comment">//调用 dm 的 insert 方法插入页面 返回 uid</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">rootUid</span> <span class="operator">=</span> dm.insert(TransactionManagerImpl.SUPER_ID, rawRoot); <span class="comment">//使用超级事务</span></span><br><span class="line">    <span class="comment">//返回插入结果 uid</span></span><br><span class="line">    <span class="keyword">return</span> dm.insert(TransactionManagerImpl.SUPER_ID, Parser.long2Byte(rootUid));   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	或者直接从bootuid读取一颗b+树：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * LoadBPlusTree 通过 BootUID 读取一课 B+ 树, 并返回它.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> bootUid</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> dm</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> BPlusTree <span class="title function_">load</span><span class="params">(<span class="type">long</span> bootUid, DataManager dm)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    <span class="type">DataItem</span> <span class="variable">bootDataItem</span> <span class="operator">=</span> dm.read(bootUid);   <span class="comment">//根据 uid 从缓存中取出 dataitem</span></span><br><span class="line">    <span class="keyword">assert</span> bootDataItem != <span class="literal">null</span>;</span><br><span class="line">    <span class="type">BPlusTree</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BPlusTree</span>();  <span class="comment">//创建一个 b+ 树对象</span></span><br><span class="line">    <span class="comment">//赋值</span></span><br><span class="line">    t.bootUid = bootUid;</span><br><span class="line">    t.dm = dm;</span><br><span class="line">    t.bootDataItem = bootDataItem;</span><br><span class="line">    t.bootLock = <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">return</span> t;       <span class="comment">//返回 b+树</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	接下来就是一般的对一颗b+树的相关操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BPlusTree</span> &#123;</span><br><span class="line">    DataItem bootDataItem;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * rootUID 通过bootUID读取该树的根节点地址</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> <span class="title function_">rootUid</span><span class="params">()</span>&#123;</span><br><span class="line">        bootLock.lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="type">SubArray</span> <span class="variable">sa</span> <span class="operator">=</span> bootDataItem.data();</span><br><span class="line">            <span class="keyword">return</span> Parser.parseLong(Arrays.copyOfRange(sa.raw, sa.start, sa.start + <span class="number">8</span>));    	 <span class="comment">//返回该树的根节点地址</span></span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            bootLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 因为B+树在算法执行过程中, 根节点可能会发生改变, 所以不能直接用根节点的地址当boot,</span></span><br><span class="line"><span class="comment">     * 而需要一个固定的boot, 用来指向它的根节点.</span></span><br><span class="line"><span class="comment">     * updateBootUid 更新该树的根节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> left</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> right</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> rightKey</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">updateBootUid</span><span class="params">(<span class="type">long</span> left, <span class="type">long</span> right, <span class="type">long</span> rightKey)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        bootLock.lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//先生成一个新的根节点</span></span><br><span class="line">            <span class="type">byte</span>[] rootRaw = Node.newRootRaw(left, right, rightKey);    			</span><br><span class="line">            <span class="comment">//插入页面 返回uid</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">newRootUid</span> <span class="operator">=</span> dm.insert(TransactionManagerImpl.SUPER_ID, rootRaw);  </span><br><span class="line">            bootDataItem.before();  <span class="comment">//更新前加写锁 设置脏页</span></span><br><span class="line">            <span class="type">SubArray</span> <span class="variable">diRaw</span> <span class="operator">=</span> bootDataItem.data();</span><br><span class="line">            System.arraycopy(Parser.long2Byte(newRootUid), <span class="number">0</span>, diRaw.raw, diRaw.start, <span class="number">8</span>);</span><br><span class="line">            bootDataItem.after(TransactionManagerImpl.SUPER_ID);   <span class="comment">//更新完成后 解锁 生成日志</span></span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            bootLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * searchLeaf 根据key, 在nodeUUID代表节点的子树中搜索, 直到找到其对应的叶节点对应的 uid.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nodeUid</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> <span class="title function_">searchLeaf</span><span class="params">(<span class="type">long</span> nodeUid, <span class="type">long</span> key)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> Node.loadNode(<span class="built_in">this</span>, nodeUid);   <span class="comment">//根据nodeUid 返回树中其对应的节点</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isLeaf</span> <span class="operator">=</span> node.isLeaf();     <span class="comment">//判断是否为叶子节点</span></span><br><span class="line">        node.release();     <span class="comment">//驱逐 dataitem 缓存</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(isLeaf)&#123;</span><br><span class="line">            <span class="keyword">return</span> nodeUid; <span class="comment">//如果是叶子节点 则直接返回当前的 uid</span></span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//如果不是叶子节点 则往右试探其兄弟节点 直到找到对应 key 的 nextid</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">next</span> <span class="operator">=</span> searchNext(nodeUid, key);   </span><br><span class="line">            <span class="keyword">return</span> searchLeaf(next, key);   <span class="comment">//递归 搜索当前节点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * serachNext 从nodeUID对应节点开始, 不断的向右试探兄弟节点, 找到对应key的next uid</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nodeUid</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> <span class="title function_">searchNext</span><span class="params">(<span class="type">long</span> nodeUid, <span class="type">long</span> key)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">//循环直到找到</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> Node.loadNode(<span class="built_in">this</span>, nodeUid);   <span class="comment">//搜索当前节点</span></span><br><span class="line">            <span class="comment">//返回一个搜索结果【找到结果的uid，和兄弟节点的uid】</span></span><br><span class="line">            Node.<span class="type">SearchNextRes</span> <span class="variable">res</span> <span class="operator">=</span> node.searchNext(key);  </span><br><span class="line">            node.release();</span><br><span class="line">            <span class="keyword">if</span>(res.uid != <span class="number">0</span>)&#123;   <span class="comment">//找到了则直接返回</span></span><br><span class="line">                <span class="keyword">return</span> res.uid;</span><br><span class="line">            &#125;</span><br><span class="line">            nodeUid = res.siblingUid;   <span class="comment">//没找到则返回兄弟节点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 搜索范围内所有的节点 最后包装成一个uid的集合返回</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> leftKey</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> rightKey</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Long&gt; <span class="title function_">searchRange</span><span class="params">(<span class="type">long</span> leftKey, <span class="type">long</span> rightKey)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">rootUid</span> <span class="operator">=</span> rootUid();       <span class="comment">//获得根节点地址</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">leafUid</span> <span class="operator">=</span> searchLeaf(rootUid, leftKey);    <span class="comment">//找到对应 leftKey 的叶节点 uid</span></span><br><span class="line">        List&lt;Long&gt; uids = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="comment">// 不断的从leaf向sibling迭代, 将所有满足的uid都加入</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">leaf</span> <span class="operator">=</span> Node.loadNode(<span class="built_in">this</span>, leafUid);   <span class="comment">//搜索当前 uid</span></span><br><span class="line">            <span class="comment">//返回一个搜索结果【搜索到的 uid 集合，兄弟节点uid】</span></span><br><span class="line">            Node.<span class="type">LeafSearchRangeRes</span> <span class="variable">res</span> <span class="operator">=</span> leaf.leafSearchRange(leftKey, rightKey);  </span><br><span class="line">            leaf.release();</span><br><span class="line">            uids.addAll(res.uids);  <span class="comment">//将搜索到元素加入集合 uids</span></span><br><span class="line">            <span class="keyword">if</span>(res.siblingUid == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;  <span class="comment">//当不存在兄弟节点时  结束 搜索到了末尾哦</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                leafUid = res.siblingUid;   <span class="comment">//否则兄弟节点uid 赋给 leafuid 进行递归</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uids;    <span class="comment">//返回范围内 uid 集合</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * insert 将(uid, key)插入到 B+ 树中, 如果有分裂, 则将分裂产生的新节点也返回.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nodeUid</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> uid</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> InsertRes <span class="title function_">insert</span><span class="params">(<span class="type">long</span> nodeUid, <span class="type">long</span> uid, <span class="type">long</span> key)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> Node.loadNode(<span class="built_in">this</span>, nodeUid);   <span class="comment">//读入当前节点</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isLeaf</span> <span class="operator">=</span> node.isLeaf();     <span class="comment">//判断当前节点是否叶子节点</span></span><br><span class="line">        node.release();</span><br><span class="line"></span><br><span class="line">        <span class="type">InsertRes</span> <span class="variable">res</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(isLeaf)&#123;</span><br><span class="line">             <span class="comment">//如果是叶子节点 则需要往右试探兄弟节点 找到合适位置插入</span></span><br><span class="line">            res = insertAndSplit(nodeUid, uid, key);   </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//若非叶子节点</span></span><br><span class="line">            <span class="comment">//向右试探当前节点【非叶子节点】的兄弟节点，返回nextuid</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">next</span> <span class="operator">=</span> searchNext(nodeUid, key);   </span><br><span class="line">            <span class="type">InsertRes</span> <span class="variable">ir</span> <span class="operator">=</span> insert(next, uid, key);  <span class="comment">//插入b+树 返回插入结果【新节点，新key】</span></span><br><span class="line">            <span class="keyword">if</span>(ir.newNode != <span class="number">0</span>)&#123;    <span class="comment">//新节点不为0</span></span><br><span class="line">                <span class="comment">//将新节点往叶子节点插入</span></span><br><span class="line">                res = insertAndSplit(nodeUid, ir.newNode, ir.newKey);   </span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;     <span class="comment">//新节点为0</span></span><br><span class="line">                res = <span class="keyword">new</span> <span class="title class_">InsertRes</span>();  <span class="comment">//直接返回插入结果</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 插入节点会造成b+树分裂</span></span><br><span class="line"><span class="comment">     * insertAndSplit 函数从node开始, 不断的向右试探兄弟节点, 直到找到一个节点, 能够插入进对应的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nodeUid</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> uid</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> InsertRes <span class="title function_">insertAndSplit</span><span class="params">(<span class="type">long</span> nodeUid, <span class="type">long</span> uid, <span class="type">long</span> key)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">//不断循环</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> Node.loadNode(<span class="built_in">this</span>, nodeUid);   <span class="comment">//读入一个uid 返回对应节点</span></span><br><span class="line">            Node.<span class="type">InsertAndSplitRes</span> <span class="variable">iasr</span> <span class="operator">=</span> node.insertAndSplit(uid, key);    <span class="comment">//</span></span><br><span class="line">            node.release();</span><br><span class="line">            <span class="keyword">if</span>(iasr.siblingUid != <span class="number">0</span>) &#123;</span><br><span class="line">                nodeUid = iasr.siblingUid;  <span class="comment">//兄弟节点不为0 赋值调用</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//兄弟节点为0  插入对应的节点</span></span><br><span class="line">                <span class="type">InsertRes</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InsertRes</span>();</span><br><span class="line">                res.newNode = iasr.newSon;</span><br><span class="line">                res.newKey = iasr.newKey;</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	IM 对上层模块主要提供两种能力：插入索引和搜索节点。</p>
<p>​	PS. IM 为什么不提供删除索引的能力。当上层模块通过 VM 删除某个 Entry，实际的操作是设置其 XMAX。如果不去删除对应索引的话，当后续再次尝试读取该 Entry 时，是可以通过索引寻找到的，但是由于设置了 XMAX，寻找不到合适的版本而返回一个找不到内容的错误。</p>
<h2 id="可能的错误与恢复"><a href="#可能的错误与恢复" class="headerlink" title="可能的错误与恢复"></a>可能的错误与恢复</h2><p>​	B+ 树在操作过程中，可能出现两种错误，分别是节点内部错误和节点间关系错误。 当节点内部错误发生时，即当 Ti 在对节点的数据进行更改时，MYDB 发生了崩溃。由于 IM 依赖于 DM，在数据库重启后，Ti 会被撤销（undo），对节点的错误影响会被消除。 如果出现了节点间错误，那么一定是下面这种情况：某次对 u 节点的插入操作创建了新节点 v, 此时 sibling(u)&#x3D;v，但是 v 却并没有被插入到父节点中。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[parent]</span></span><br><span class="line">    |</span><br><span class="line">    v</span><br><span class="line">   <span class="selector-attr">[u]</span> -&gt; <span class="selector-attr">[v]</span></span><br></pre></td></tr></table></figure>

<p>​		正确的状态应当如下：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[ parent ]</span></span><br><span class="line"> |      |</span><br><span class="line"> v      v</span><br><span class="line"><span class="selector-attr">[u]</span> -&gt; <span class="selector-attr">[v]</span></span><br></pre></td></tr></table></figure>

<p>​	这时，如果要对节点进行插入或者搜索操作，如果失败，就会继续迭代它的兄弟节点，最终还是可以找到 v 节点。唯一的缺点仅仅是，无法直接通过父节点找到 v 了，只能间接地通过 u 获取到 v。</p>
<h1 id="字段与表管理TBM"><a href="#字段与表管理TBM" class="headerlink" title="字段与表管理TBM"></a>字段与表管理TBM</h1><p>​	本章概述 TBM，即表<strong>管理器</strong>的实现。TBM 实现了对字段结构和表结构的管理。同时简要介绍 MYDB 使用的类 SQL 语句的解析。</p>
<h2 id="1、首先是SQL-解析器"><a href="#1、首先是SQL-解析器" class="headerlink" title="1、首先是SQL 解析器"></a>1、首先是SQL 解析器</h2><p>​	<strong>Parser 实现</strong>了对类 <strong>SQL 语句的结构化解析</strong>，将语句中包含的信息封装为对应语句的类，这些类可见 top.guoziyang.mydb.backend.parser.statement 包.</p>
<p>​	parser 包的 Tokenizer 类，对语句进行逐字节解析，根据空白符或者上述词法规则，将语句切割成多个 token。</p>
<p>​	Tokenizer类中主要属性 ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> flushToken;     <span class="comment">//pop之后置为true，取下一个token</span></span><br></pre></td></tr></table></figure>

<p>​	对外提供了 peek()、pop() 方法方便取出 Token 进行解析。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取语句中 第一个 token</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">peek</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">if</span>(err != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flushToken) &#123;   <span class="comment">//flushToken 为 true 时  获取当前token</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            token = next();     <span class="comment">//获取第一个 分词token</span></span><br><span class="line">        &#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">            err = e;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">        currentToken = token;</span><br><span class="line">        flushToken = <span class="literal">false</span>;     <span class="comment">//当前 token 获取完毕 将 flushtoken 重新置为 false</span></span><br><span class="line">    &#125;      </span><br><span class="line">    <span class="keyword">return</span> currentToken;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * pop 将 flushtoken 置为 true， 用于获取下一个 token</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">    flushToken = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<pre><code> Parser 类就是一个SQL解析器，直接对外提供了 Parse(byte[] statement) 方法，核心就是一个调用 Tokenizer 类分割 Token，并根据词法规则包装成具体的 Statement 类并返回。解析过程根据第一个 Token 来区分语句类型，并分别处理，下面就是解析方法，还剩下的就是具体的每个sql类型语句的处理方法。
</code></pre>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 调用 Tokenizer 类分割 Token，并根据词法规则包装成具体的 Statement 类并返回</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> statement</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">Parse</span><span class="params">(<span class="type">byte</span>[] statement)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">Tokenizer</span> <span class="variable">tokenizer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Tokenizer</span>(statement);</span><br><span class="line">    <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> tokenizer.peek();    <span class="comment">//获取sql 语句中第一个token</span></span><br><span class="line">    tokenizer.pop();</span><br><span class="line"></span><br><span class="line">    <span class="type">Object</span> <span class="variable">stat</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">Exception</span> <span class="variable">statErr</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="comment">//根据 token 数组中 第一个token 来区分 sql 语句的类型 分别调用不同的方法去处理</span></span><br><span class="line">       <span class="keyword">switch</span>(token) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;begin&quot;</span>:</span><br><span class="line">                stat = parseBegin(tokenizer);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;commit&quot;</span>:</span><br><span class="line">                stat = parseCommit(tokenizer);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;abort&quot;</span>:</span><br><span class="line">                stat = parseAbort(tokenizer);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;create&quot;</span>:</span><br><span class="line">                stat = parseCreate(tokenizer);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;drop&quot;</span>:</span><br><span class="line">                stat = parseDrop(tokenizer);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;select&quot;</span>:</span><br><span class="line">                stat = parseSelect(tokenizer);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;insert&quot;</span>:</span><br><span class="line">                stat = parseInsert(tokenizer);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;delete&quot;</span>:</span><br><span class="line">                stat = parseDelete(tokenizer);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;update&quot;</span>:</span><br><span class="line">                stat = parseUpdate(tokenizer);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;show&quot;</span>:</span><br><span class="line">                stat = parseShow(tokenizer);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> Error.InvalidCommandException;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">        statErr = e;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//异常处理</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">next</span> <span class="operator">=</span> tokenizer.peek();</span><br><span class="line">        <span class="keyword">if</span>(!<span class="string">&quot;&quot;</span>.equals(next)) &#123;</span><br><span class="line">            <span class="type">byte</span>[] errStat = tokenizer.errStat();</span><br><span class="line">            statErr = <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Invalid statement: &quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(errStat));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="type">byte</span>[] errStat = tokenizer.errStat();</span><br><span class="line">        statErr = <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Invalid statement: &quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(errStat));     	 &#125;</span><br><span class="line">    <span class="keyword">if</span>(statErr != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> statErr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="2、单个字段信息和表信息的储存结构"><a href="#2、单个字段信息和表信息的储存结构" class="headerlink" title="2、单个字段信息和表信息的储存结构"></a>2、单个字段信息和表信息的储存结构</h2><p>​	由于 TBM 基于 VM，单个字段信息和表信息都是直接保存在 Entry 中。</p>
<p>   Field字段的二进制表示如下：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[FieldName]</span><span class="selector-attr">[TypeName]</span><span class="selector-attr">[IndexUid]</span></span><br></pre></td></tr></table></figure>

<p>​	这里 FieldName 和 TypeName,存储的都是字节形式的字符串。</p>
<p>​	这里规定一个字符串的存储方式，以明确其存储边界。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[StringLength]</span><span class="selector-attr">[StringData]</span></span><br></pre></td></tr></table></figure>

<p>​	TypeName 为字段的类型，限定为 int32、int64 和 string 类型。如果这个字段有索引，那个 IndexUID 指向了索引二叉树的根，否则该字段为 0。</p>
<h2 id="3、根据-UID-读取并解析单个字段和表信息"><a href="#3、根据-UID-读取并解析单个字段和表信息" class="headerlink" title="3、根据 UID 读取并解析单个字段和表信息"></a>3、根据 UID 读取并解析单个字段和表信息</h2><p>​	根据这个结构，通过一个 UID 从 VM 中读取并解析如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过一个 uid 从 vm 中读取字段</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> tb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> uid</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Field <span class="title function_">loadField</span><span class="params">(Table tb, <span class="type">long</span> uid)</span>&#123;</span><br><span class="line">    <span class="type">byte</span>[] raw = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="comment">//vm 中获取的 entry 数据</span></span><br><span class="line">        raw = ((TableManagerImpl) tb.tbm).vm.read(TransactionManagerImpl.SUPER_ID, uid); </span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">        Panic.panic(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">assert</span> raw != <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Field</span>(uid, tb).parseSelf(raw);   <span class="comment">//entry 数据解析成 field，存入一个 Field 对象</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从 vm 中读取一个 entry 后，调用此方法解析出 Field</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> raw</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> Field <span class="title function_">parseSelf</span><span class="params">(<span class="type">byte</span>[] raw)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">position</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">ParseStringRes</span> <span class="variable">res</span> <span class="operator">=</span> Parser.parseString(raw);</span><br><span class="line">    fieldName = res.str;        <span class="comment">//解析出字段名</span></span><br><span class="line">    position += res.next;</span><br><span class="line">    res = Parser.parseString(Arrays.copyOfRange(raw, position, raw.length));</span><br><span class="line">    fieldType = res.str;        <span class="comment">//解析出字段类型</span></span><br><span class="line">    position += res.next;</span><br><span class="line">    <span class="comment">//解析出索引数据</span></span><br><span class="line">    <span class="built_in">this</span>.index = Parser.parseLong(Arrays.copyOfRange(raw, position, position + <span class="number">8</span>)); </span><br><span class="line">    <span class="keyword">if</span>(index != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            bt = BPlusTree.load(index, ((TableManagerImpl)tb.tbm).dm);  <span class="comment">//将索引加入b+树</span></span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            Panic.panic(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4、持久化信息"><a href="#4、持久化信息" class="headerlink" title="4、持久化信息"></a>4、持久化信息</h2><p>​	创建一个字段的方法类似，将相关的信息通过 VM 持久化即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 字段名 字段类型 索引 都转为字节 通过 vm 的 insert 方法，包裹成 entry 插入页面</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> xid</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">persistSelf</span><span class="params">(<span class="type">long</span> xid)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">byte</span>[] nameRaw = Parser.string2Byte(fieldName);</span><br><span class="line">    <span class="type">byte</span>[] typeRaw = Parser.string2Byte(fieldType);</span><br><span class="line">    <span class="type">byte</span>[] indexRaw = Parser.long2Byte(index);</span><br><span class="line">    <span class="built_in">this</span>.uid = ((TableManagerImpl)tb.tbm).vm.insert(xid, Bytes.concat(nameRaw, typeRaw, indexRaw));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5、链表管理管理多张表"><a href="#5、链表管理管理多张表" class="headerlink" title="5、链表管理管理多张表"></a>5、链表管理管理多张表</h2><p>​	一个数据库中存在多张表，TBM 使用<strong>链表</strong>的形式将其组织起来，每一张表都保存一个指向下一张表的 UID。表的二进制结构如下：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[TableName]</span><span class="selector-attr">[NextTable]</span></span><br><span class="line"><span class="selector-attr">[Field1Uid]</span><span class="selector-attr">[Field2Uid]</span>...<span class="selector-attr">[FieldNUid]</span></span><br></pre></td></tr></table></figure>

<p>​	这里由于每个 Entry 中的数据，字节数是确定的，于是无需保存字段的个数。Table 维护了表结构，表信息也是保存在 Entry 中，根据 UID 从 Entry 中读取表数据的过程和读取字段的过程类似。 </p>
<p>​	首先需要读取一个表或者创建一个新的表</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过一个 uid 从 vm 中读取表</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> tbm</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> uid</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Table <span class="title function_">loadTable</span><span class="params">(TableManager tbm, <span class="type">long</span> uid)</span>&#123;</span><br><span class="line">    <span class="type">byte</span>[] raw = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//vm 中获取的 entry 数据</span></span><br><span class="line">        raw = ((TableManagerImpl)tbm).vm.read(TransactionManagerImpl.SUPER_ID, uid);   </span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        Panic.panic(e);</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">assert</span> raw != <span class="literal">null</span>;</span><br><span class="line">    <span class="type">Table</span> <span class="variable">tb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Table</span>(tbm, uid);</span><br><span class="line">    <span class="keyword">return</span> tb.parseSelf(raw);   <span class="comment">//entry 数据解析成 table，存入 Table 对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 从 vm 中读取一个 entry 后，调用此方法解析出 Table 【解析的具体方法】</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> raw</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> Table <span class="title function_">parseSelf</span><span class="params">(<span class="type">byte</span>[] raw)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">position</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">ParseStringRes</span> <span class="variable">res</span> <span class="operator">=</span> Parser.parseString(raw);</span><br><span class="line">    name = res.str;     <span class="comment">//解析出表名</span></span><br><span class="line">    position += res.next;</span><br><span class="line">    <span class="comment">//解析出下一个指针名</span></span><br><span class="line">    nextUid = Parser.parseLong(Arrays.copyOfRange(raw, position, position+<span class="number">8</span>));      </span><br><span class="line">    position += <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(position &lt; raw.length) &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">uid</span> <span class="operator">=</span> Parser.parseLong(Arrays.copyOfRange(raw, position, position+<span class="number">8</span>));</span><br><span class="line">        position += <span class="number">8</span>;</span><br><span class="line">        fields.add(Field.loadField(<span class="built_in">this</span>, uid)); <span class="comment">//加载表的每个字段信息</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *创建一个新表</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> tbm</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> nextUid</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> xid</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> create</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Table <span class="title function_">createTable</span><span class="params">(TableManager tbm, <span class="type">long</span> nextUid, <span class="type">long</span> xid, Create create)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">Table</span> <span class="variable">tb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Table</span>(tbm, create.tableName, nextUid);   <span class="comment">//创建表对象</span></span><br><span class="line">    <span class="comment">//依次读取表中的每个字段名和字段类型</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; create.fieldName.length; i ++) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">fieldName</span> <span class="operator">=</span> create.fieldName[i];</span><br><span class="line">        <span class="type">String</span> <span class="variable">fieldType</span> <span class="operator">=</span> create.fieldType[i];</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">indexed</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//依次为其加上索引</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; create.index.length; j ++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(fieldName.equals(create.index[j])) &#123;</span><br><span class="line">               indexed = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//放入table 表对象</span></span><br><span class="line">        tb.fields.add(Field.createField(tb, xid, fieldName, fieldType, indexed));  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tb.persistSelf(xid);     <span class="comment">//表的事务信息持久化</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	以上 ，还有剩下的就是删除、更新、插入以及查询表字段的操作方法；</p>
<p>​	对表和字段的操作，有一个很重要的步骤，就是计算 Where 条件的范围，目前 MYDB 的 Where 只支持两个条件的与和或。例如有条件的 Delete，计算 Where，最终就需要获取到条件范围内所有的 UID。MYDB 只支持已索引字段作为 Where 的条件。计算 Where 的范围，具体可以查看 Table 的 parseWhere() 和 calWhere() 方法，以及 Field 类的 calExp() 方法。【代码就不贴了】</p>
<p>​	由于 TBM 的表管理，使用的是链表串起的 Table 结构，所以就必须保存一个链表的头节点，即第一个表的 UID，这样在 MYDB 启动时，才能快速找到表信息。 </p>
<p>​	MYDB 使用 Booter 类和 bt 文件，来管理 MYDB 的启动信息，虽然现在所需的启动信息，只有一个：头表的 UID。Booter 类对外提供了两个方法：load 和 update，并保证了其原子性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 加载第一个表的 uid</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">byte</span>[] load() &#123;</span><br><span class="line">    <span class="type">byte</span>[] buf = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        buf = Files.readAllBytes(file.toPath());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        Panic.panic(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	update 在修改 bt 文件内容时，没有直接对 bt 文件进行修改，而是首先将内容写入一个 bt_tmp 文件中，随后将这个文件重命名为 bt 文件。以期通过操作系统重命名文件的原子性，来保证操作的原子性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 采用的头插法 需要</span></span><br><span class="line"><span class="comment">* 更新第一个表的 uid</span></span><br><span class="line"><span class="comment">* 修改 bt 文件的内容</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> data</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">byte</span>[] data)</span> &#123;</span><br><span class="line">    <span class="type">File</span> <span class="variable">tmp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(path + BOOTER_TMP_SUFFIX);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        tmp.createNewFile();    <span class="comment">//创建一个 tmp File文件</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        Panic.panic(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!tmp.canRead() || !tmp.canWrite()) &#123;</span><br><span class="line">        Panic.panic(Error.FileCannotRWException);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span>(<span class="type">FileOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(tmp)) &#123;</span><br><span class="line">        out.write(data);</span><br><span class="line">        out.flush();</span><br><span class="line">    &#125; <span class="keyword">catch</span>(IOException e) &#123;</span><br><span class="line">        Panic.panic(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//将 tmp 中的内容 写入新的 bt 文件【替换】</span></span><br><span class="line">        Files.move(tmp.toPath(), <span class="keyword">new</span> <span class="title class_">File</span>(path + BOOTER_SUFFIX).toPath(), StandardCopyOption.REPLACE_EXISTING);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(IOException e) &#123;</span><br><span class="line">        Panic.panic(e);</span><br><span class="line">    &#125;</span><br><span class="line">    file = <span class="keyword">new</span> <span class="title class_">File</span>(path + BOOTER_SUFFIX);  <span class="comment">//将 tmp 文件重命名为 bt 文件 加上后缀</span></span><br><span class="line">    <span class="keyword">if</span>(!file.canRead() || !file.canWrite()) &#123;</span><br><span class="line">        Panic.panic(Error.FileCannotRWException);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="TableManager"><a href="#TableManager" class="headerlink" title="TableManager"></a>TableManager</h2><p>​	TBM 层对外提供服务的是 TableManager 接口，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">TableManager</span> &#123;</span><br><span class="line">    BeginRes <span class="title function_">begin</span><span class="params">(Begin begin)</span>;</span><br><span class="line">    <span class="type">byte</span>[] commit(<span class="type">long</span> xid) <span class="keyword">throws</span> Exception;</span><br><span class="line">    <span class="type">byte</span>[] abort(<span class="type">long</span> xid);</span><br><span class="line"> </span><br><span class="line">    <span class="type">byte</span>[] show(<span class="type">long</span> xid);</span><br><span class="line">    <span class="type">byte</span>[] create(<span class="type">long</span> xid, Create create) <span class="keyword">throws</span> Exception;</span><br><span class="line"> </span><br><span class="line">    <span class="type">byte</span>[] insert(<span class="type">long</span> xid, Insert insert) <span class="keyword">throws</span> Exception;</span><br><span class="line">    <span class="type">byte</span>[] read(<span class="type">long</span> xid, Select select) <span class="keyword">throws</span> Exception;</span><br><span class="line">    <span class="type">byte</span>[] update(<span class="type">long</span> xid, Update update) <span class="keyword">throws</span> Exception;</span><br><span class="line">    <span class="type">byte</span>[] delete(<span class="type">long</span> xid, Delete delete) <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	由于 TableManager 已经是直接被最外层 Server 调用（MYDB 是 C&#x2F;S 结构），这些方法直接返回执行的结果，例如错误信息或者结果信息的字节数组（可读）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TableManagerImpl</span> <span class="keyword">implements</span> <span class="title class_">TableManager</span>&#123;</span><br><span class="line">    VersionManager vm;</span><br><span class="line">    DataManager dm;</span><br><span class="line">    <span class="keyword">private</span> Booter booter;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Table&gt; tableCache;          <span class="comment">//表缓存</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Long, List&lt;Table&gt;&gt; xidTableCache;      <span class="comment">//一个事务对应的表缓存</span></span><br><span class="line">    <span class="keyword">private</span> Lock lock;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	各个对表相关操作的方法具体实现在TableManagerImpl中，基本就是调用 VM 的相关方法。实现类中引入了表缓存和每个事务对应的表的缓存，用以实现隔离性。</p>
<p>​	唯一值得注意的一个小点是，在创建新表时，采用的是头插法，所以每次创建表都需要更新 Booter 文件。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 创建表</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> xid</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> create</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">* <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">byte</span>[] create(<span class="type">long</span> xid, Create create) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(tableCache.containsKey(create.tableName)) &#123;  <span class="comment">//如果缓存中存在 报重复表错</span></span><br><span class="line">            <span class="keyword">throw</span> Error.DuplicatedTableException;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Table</span> <span class="variable">table</span> <span class="operator">=</span> Table.createTable(<span class="built_in">this</span>, firstTableUid(), xid, create); <span class="comment">//创建一个新表</span></span><br><span class="line">        updateFirstTableUid(table.uid);     <span class="comment">//更新其uid  因为采用头插法 新表放在最前面</span></span><br><span class="line">        tableCache.put(create.tableName, table);    <span class="comment">//加入表缓存</span></span><br><span class="line">        <span class="keyword">if</span>(!xidTableCache.containsKey(xid)) &#123;</span><br><span class="line">            xidTableCache.put(xid, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());      <span class="comment">//加入对应的事务缓存</span></span><br><span class="line">        &#125;</span><br><span class="line">        xidTableCache.get(xid).add(table);</span><br><span class="line">        <span class="keyword">return</span> (<span class="string">&quot;create &quot;</span> + create.tableName).getBytes();       <span class="comment">//返回创建结果信息</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="服务端客户端的实现及其通信规则"><a href="#服务端客户端的实现及其通信规则" class="headerlink" title="服务端客户端的实现及其通信规则"></a>服务端客户端的实现及其通信规则</h1><p>​	MyDB 被设计为 C&#x2F;S 结构，类似于 MySQL。支持启动一个服务器，并有多个客户端去连接，通过 socket 通信，执行 SQL 返回结果。</p>
<h2 id="C-x2F-S-通信"><a href="#C-x2F-S-通信" class="headerlink" title="C&#x2F;S 通信"></a>C&#x2F;S 通信</h2><h3 id="1、CS之间通信的基本结构-Package"><a href="#1、CS之间通信的基本结构-Package" class="headerlink" title="1、CS之间通信的基本结构 Package"></a>1、CS之间通信的基本结构 Package</h3><p>​	MYDB 使用了一种特殊的二进制格式，用于客户端和服务端通信。</p>
<p>​	传输的最基本结构，是 Package：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Package</span> &#123;</span><br><span class="line">    <span class="type">byte</span>[] data;</span><br><span class="line">    Exception err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、编码与解码规则"><a href="#2、编码与解码规则" class="headerlink" title="2、编码与解码规则"></a>2、编码与解码规则</h3><p>​	每个 Package 在发送前，由 Encoder 编码为字节数组，在对方收到后同样会由 Encoder 解码成 Package 对象。发送编码的格式为</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[Flag]</span><span class="selector-attr">[data]</span></span><br></pre></td></tr></table></figure>

<p>​	若 flag 为 0，表示发送的是数据，那么 data 即为这份数据本身；如果 flag 为 1，表示发送的是错误，data 是 Exception.getMessage() 的错误提示信息，编解码类代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Encoder</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 编码方法 编码为字节数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pkg</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">byte</span>[] encode(Package pkg) &#123;</span><br><span class="line">        <span class="keyword">if</span>(pkg.getErr() != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">Exception</span> <span class="variable">err</span> <span class="operator">=</span> pkg.getErr();</span><br><span class="line">            <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;Intern server error!&quot;</span>;</span><br><span class="line">            <span class="keyword">if</span>(err.getMessage() != <span class="literal">null</span>) &#123;</span><br><span class="line">                msg = err.getMessage();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//flag 为 0，表示发送的数据 data 就是数据本身</span></span><br><span class="line">            <span class="keyword">return</span> Bytes.concat(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="number">1</span>&#125;, msg.getBytes());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//flag 为 1，表示发送的错误信息 data是错误提示信息</span></span><br><span class="line">            <span class="keyword">return</span> Bytes.concat(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="number">0</span>&#125;, pkg.getData());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解码方法 解码成 package 对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Package <span class="title function_">decode</span><span class="params">(<span class="type">byte</span>[] data)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">if</span>(data.length &lt; <span class="number">1</span>) &#123;   <span class="comment">//数据长度小于1  则为无效数据</span></span><br><span class="line">            <span class="keyword">throw</span> Error.InvalidPkgDataException;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(data[<span class="number">0</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//第一个字节为 0 时，正常数据 需要转成 package 对象</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Package</span>(Arrays.copyOfRange(data, <span class="number">1</span>, data.length), <span class="literal">null</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(data[<span class="number">0</span>] == <span class="number">1</span>) &#123;   <span class="comment">//第一个字节为 1 时  表示错误信息</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Package</span>(<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="keyword">new</span> <span class="title class_">String</span>(Arrays.copyOfRange(data, <span class="number">1</span>, data.length))));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> Error.InvalidPkgDataException;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3、通过-Transporter-类，写入输出流发送信息"><a href="#3、通过-Transporter-类，写入输出流发送信息" class="headerlink" title="3、通过 Transporter 类，写入输出流发送信息"></a>3、通过 Transporter 类，写入输出流发送信息</h3><p>​	编码之后的信息会通过 Transporter 类，写入输出流发送出去。为了避免特殊字符造成问题，这里会将数据转成十六进制字符串（Hex String），并为信息末尾加上换行符。这样在发送和接收数据时，就可以很简单地使用 BufferedReader 和 Writer 来直接按行读写了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Transporter</span> &#123;</span><br><span class="line">	...</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发送方法 避免特殊字符出现问题 将数据转换成16进制字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">(<span class="type">byte</span>[] data)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">raw</span> <span class="operator">=</span> hexEncode(data);   <span class="comment">//将数据转换成 16进制 字符串</span></span><br><span class="line">        writer.write(raw);  <span class="comment">//写入到 writer</span></span><br><span class="line">        writer.flush();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 接收方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">byte</span>[] receive() <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> reader.readLine();    <span class="comment">//从 reader 中按行读取数据</span></span><br><span class="line">        <span class="keyword">if</span>(line == <span class="literal">null</span>) &#123;</span><br><span class="line">            close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hexDecode(line);     <span class="comment">//对其进行解码</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将数据转成16进制字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> buf</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">hexEncode</span><span class="params">(<span class="type">byte</span>[] buf)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Hex.encodeHexString(buf, <span class="literal">true</span>) + <span class="string">&quot;\n&quot;</span>; <span class="comment">//在后面加上换行符 以方便按行读写</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将16进制字符串解码成 byte数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> buf</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> DecoderException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">byte</span>[] hexDecode(String buf) <span class="keyword">throws</span> DecoderException &#123;</span><br><span class="line">        <span class="keyword">return</span> Hex.decodeHex(buf);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4、Packager-中对外提供的-send-和-receive-方法"><a href="#4、Packager-中对外提供的-send-和-receive-方法" class="headerlink" title="4、Packager 中对外提供的 send 和 receive 方法"></a>4、Packager 中对外提供的 send 和 receive 方法</h3><p>​	Packager 则是 Encoder 和 Transporter 的结合体，直接对外提供 send 和 receive 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Packager</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对外发送数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pkg</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">(Package pkg)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">byte</span>[] data = encoder.encode(pkg);  <span class="comment">//package数据包编码</span></span><br><span class="line">        transporter.send(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对外接收数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Package <span class="title function_">receive</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">byte</span>[] data = transporter.receive();    <span class="comment">//接受数据</span></span><br><span class="line">        <span class="keyword">return</span> encoder.decode(data);    <span class="comment">//收到的data数据解码变成package数据包</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Server-和-Client-的实现"><a href="#Server-和-Client-的实现" class="headerlink" title="Server 和 Client 的实现"></a>Server 和 Client 的实现</h2><p>​	Server 和 Client，偷懒直接使用了 Java 的 socket。 </p>
<h3 id="1、服务端实现"><a href="#1、服务端实现" class="headerlink" title="1、服务端实现"></a>1、服务端实现</h3><p>​	Server 启动一个 ServerSocket 监听端口，当有请求到来时直接把请求丢给一个新线程处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">ServerSocket</span> <span class="variable">ss</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ss = <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(port);    <span class="comment">//启动了一个 serversocket 监听 port 端口</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;Server listen to port:&quot;</span> + port);</span><br><span class="line">    <span class="comment">//创建一个线程池</span></span><br><span class="line">    <span class="type">ThreadPoolExecutor</span> <span class="variable">tpe</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">10</span>, <span class="number">20</span>, <span class="number">1L</span>, TimeUnit.SECONDS, <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">100</span>), <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.CallerRunsPolicy());</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> ss.accept();    <span class="comment">//serversocket 接受到了新请求</span></span><br><span class="line">            <span class="type">Runnable</span> <span class="variable">worker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HandleSocket</span>(socket, tbm);</span><br><span class="line">            tpe.execute(worker);    <span class="comment">//把请求丢给一个新线程处理</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ss.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ignored) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	HandleSocket 类实现了 Runnable 接口，在建立连接后初始化 Packager，随后就循环接收来自客户端的数据并处理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">InetSocketAddress</span> <span class="variable">address</span> <span class="operator">=</span> (InetSocketAddress) socket.getRemoteSocketAddress();        <span class="comment">//建立连接</span></span><br><span class="line">    System.out.println(<span class="string">&quot;Establish connection: &quot;</span> + address.getAddress().getHostAddress() + <span class="string">&quot;:&quot;</span> + address.getPort());</span><br><span class="line">    <span class="type">Packager</span> <span class="variable">packager</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">Transporter</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Transporter</span>(socket);</span><br><span class="line">        <span class="type">Encoder</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Encoder</span>();</span><br><span class="line">        packager = <span class="keyword">new</span> <span class="title class_">Packager</span>(t, e);  <span class="comment">//初始化一个package</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            socket.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e1) &#123;</span><br><span class="line">            e1.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">Executor</span> <span class="variable">exe</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Executor</span>(tbm);</span><br><span class="line">    <span class="comment">//循环接受来自客户端的信息【sql 】 并且进行对应的处理</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="type">Package</span> <span class="variable">pkg</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            pkg = packager.receive();   <span class="comment">//接收客户端发来的 package</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">byte</span>[] sql = pkg.getData();     <span class="comment">//获取 package 中的 sql 数据</span></span><br><span class="line">        <span class="type">byte</span>[] result = <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Exception</span> <span class="variable">e</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            result = exe.execute(sql);  <span class="comment">//解析处理 sql 数据</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e1) &#123;</span><br><span class="line">            e = e1;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        pkg = <span class="keyword">new</span> <span class="title class_">Package</span>(result, e);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            packager.send(pkg);     <span class="comment">//处理完发送到下一个模块 tbm</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e1) &#123;</span><br><span class="line">            e1.printStackTrace();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    exe.close();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        packager.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	处理的核心是 Executor 类，Executor 调用 Parser 获取到对应语句的结构化信息对象，并根据对象的类型，调用 TBM 的不同方法进行处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 解析客户端发送的 sql 语句，调用 tbm 中方法进行处理</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> sql</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">byte</span>[] execute(<span class="type">byte</span>[] sql) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Execute: &quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(sql));</span><br><span class="line">    <span class="type">Object</span> <span class="variable">stat</span> <span class="operator">=</span> Parser.Parse(sql);    		<span class="comment">//解析 sql，返回一个object对象</span></span><br><span class="line">    <span class="comment">//java.lang.Class 类的 isInstance() 方法用于检查指定的对象是否兼容分配给该 Class 的实例。</span></span><br><span class="line">    <span class="comment">// 如果指定对象为非null，并且可以强制转换为此类的实例，则该方法返回true。否则返回false。</span></span><br><span class="line">    <span class="keyword">if</span>(Begin.class.isInstance(stat)) &#123;  		<span class="comment">//如果 stat 解析出来一个 begin 对象</span></span><br><span class="line">        <span class="keyword">if</span>(xid != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> Error.NestedTransactionException;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">BeginRes</span> <span class="variable">r</span> <span class="operator">=</span> tbm.begin((Begin)stat); 	<span class="comment">//调用 tbm 的 begin 方法，开始一个事务</span></span><br><span class="line">        xid = r.xid;        					<span class="comment">//事务 xid</span></span><br><span class="line">        <span class="keyword">return</span> r.result;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(Commit.class.isInstance(stat)) &#123;  <span class="comment">//如果 stat 解析出来一个 commit 对象</span></span><br><span class="line">        <span class="keyword">if</span>(xid == <span class="number">0</span>) &#123; </span><br><span class="line">            <span class="keyword">throw</span> Error.NoTransactionException;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">byte</span>[] res = tbm.commit(xid);   		<span class="comment">//调用 tbm 的 commit 方法，提交一个事务</span></span><br><span class="line">        xid = <span class="number">0</span>;    							<span class="comment">//提交之后 xid 置为 0</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(Abort.class.isInstance(stat)) &#123;   <span class="comment">//如果 stat 解析出来一个 abort 对象</span></span><br><span class="line">        <span class="keyword">if</span>(xid == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> Error.NoTransactionException;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">byte</span>[] res = tbm.abort(xid);    		<span class="comment">//调用 tbm 的 abort 方法，回滚一个事务</span></span><br><span class="line">        xid = <span class="number">0</span>;    							<span class="comment">//回滚之后 xid 置为 0</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> execute2(stat);  				<span class="comment">//其他具体的sql语句 交给 execute2 执行</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	top.guoziyang.mydb.backend.Launcher 类，则是服务器的启动入口。这个类解析了命令行参数。很重要的参数就是 -open 或者 -create。Launcher 根据两个参数，来决定是创建数据库文件，还是启动一个已有的数据库。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">createDB</span><span class="params">(String path)</span> &#123;</span><br><span class="line">    <span class="type">TransactionManager</span> <span class="variable">tm</span> <span class="operator">=</span> TransactionManager.create(path);</span><br><span class="line">    <span class="type">DataManager</span> <span class="variable">dm</span> <span class="operator">=</span> DataManager.create(path, DEFALUT_MEM, tm);</span><br><span class="line">    <span class="type">VersionManager</span> <span class="variable">vm</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VersionManagerImpl</span>(tm, dm);</span><br><span class="line">    TableManager.create(path, vm, dm);</span><br><span class="line">    tm.close();</span><br><span class="line">    dm.close();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">openDB</span><span class="params">(String path, <span class="type">long</span> mem)</span> &#123;</span><br><span class="line">    <span class="type">TransactionManager</span> <span class="variable">tm</span> <span class="operator">=</span> TransactionManager.open(path);</span><br><span class="line">    <span class="type">DataManager</span> <span class="variable">dm</span> <span class="operator">=</span> DataManager.open(path, mem, tm);</span><br><span class="line">    <span class="type">VersionManager</span> <span class="variable">vm</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VersionManagerImpl</span>(tm, dm);</span><br><span class="line">    <span class="type">TableManager</span> <span class="variable">tbm</span> <span class="operator">=</span> TableManager.open(path, vm, dm);</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Server</span>(port, tbm).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、客户端的实现"><a href="#2、客户端的实现" class="headerlink" title="2、客户端的实现"></a>2、客户端的实现</h3><p>​	客户端连接服务器的过程，也是背板。客户端有一个简单的 Shell，实际上只是读入用户的输入，并调用 Client.execute()。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将命令行解析打包后收发处理</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> stat  输入的命令行解析结果</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">byte</span>[] execute(<span class="type">byte</span>[] stat) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">Package</span> <span class="variable">pkg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Package</span>(stat, <span class="literal">null</span>);  <span class="comment">//打包成一个package</span></span><br><span class="line">    <span class="type">Package</span> <span class="variable">resPkg</span> <span class="operator">=</span> rt.roundTrip(pkg);     <span class="comment">//单词的收发处理</span></span><br><span class="line">    <span class="keyword">if</span>(resPkg.getErr() != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> resPkg.getErr();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resPkg.getData();    <span class="comment">//返回收到的结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		RoundTripper 类实际上实现了单次收发动作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Package <span class="title function_">roundTrip</span><span class="params">(Package pkg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    packager.send(pkg);</span><br><span class="line">    <span class="keyword">return</span> packager.receive();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		最后附上客户端的启动入口，很简单，把 Shell run 起来即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Launcher</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> UnknownHostException, IOException &#123;</span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">9999</span>);</span><br><span class="line">        <span class="type">Encoder</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Encoder</span>();</span><br><span class="line">        <span class="type">Transporter</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Transporter</span>(socket);</span><br><span class="line">        <span class="type">Packager</span> <span class="variable">packager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Packager</span>(t, e);</span><br><span class="line"> </span><br><span class="line">        <span class="type">Client</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Client</span>(packager);</span><br><span class="line">        <span class="type">Shell</span> <span class="variable">shell</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Shell</span>(client);</span><br><span class="line">        shell.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>结束撒花，感谢声哥的项目，做完之后对数据库的了解更深刻，最后，放一个声哥的版权。</p>
<p># 商业转载请联系作者获得授权，非商业转载请注明出处。<br># For commercial use, please contact the author for authorization. For non-commercial use, please indicate # the source.<br># 协议(License)：署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0)<br># 作者(Author)：Ziyang<br># 链接(URL)：<a target="_blank" rel="noopener" href="https://ziyang.moe/article/mydb0.html">https://ziyang.moe/article/mydb0.html</a><br># 来源(Source)：菜狗の日常</p>

    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>爱你的晶哥
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://example.com/2022/08/10/MyDB/" title="MYDB数据库">http://example.com/2022/08/10/MyDB/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E9%A1%B9%E7%9B%AE/" rel="tag"># 项目</a>
              <a href="/tags/Mysql/" rel="tag"># Mysql</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/08/02/Redis/" rel="prev" title="秋招笔记之Redis基础">
      <i class="fa fa-chevron-left"></i> 秋招笔记之Redis基础
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/08/17/java%E8%99%9A%E6%8B%9F%E6%9C%BA/" rel="next" title="Java虚拟机">
      Java虚拟机 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#MyDB-%E7%AE%80%E4%BB%8B"><span class="nav-number">1.</span> <span class="nav-text">MyDB 简介</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B4%E4%BD%93%E7%BB%93%E6%9E%84"><span class="nav-number">1.1.</span> <span class="nav-text">整体结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%89%80%E9%9C%80%E7%9F%A5%E8%AF%86%E7%82%B9"><span class="nav-number">1.2.</span> <span class="nav-text">所需知识点</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%8E%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84-TM-%E5%BC%80%E5%A7%8B"><span class="nav-number">2.</span> <span class="nav-text">从最简单的 TM 开始</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#XID-%E6%96%87%E4%BB%B6%E7%AE%80%E4%BB%8B"><span class="nav-number">2.1.</span> <span class="nav-text">XID 文件简介</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BATM%E6%8E%A5%E5%8F%A3"><span class="nav-number">2.1.1.</span> <span class="nav-text">创建TM接口</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0"><span class="nav-number">2.2.</span> <span class="nav-text">实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%AE%9A%E4%B9%89%E5%B8%B8%E9%87%8F%E5%92%8C%E5%B1%9E%E6%80%A7"><span class="nav-number">2.2.1.</span> <span class="nav-text">1.定义常量和属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E6%A0%A1%E9%AA%8C-XID-%E6%96%87%E4%BB%B6%E4%BF%9D%E8%AF%81%E5%85%B6%E5%90%88%E6%B3%95%E6%80%A7"><span class="nav-number">2.2.2.</span> <span class="nav-text">2.校验 XID 文件保证其合法性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E6%9B%B4%E6%96%B0%E4%BA%8B%E5%8A%A1%E7%8A%B6%E6%80%81%E6%96%B9%E6%B3%95%E5%92%8C%E6%9B%B4%E6%96%B0XID%E6%96%87%E4%BB%B6%E5%A4%B4%E6%96%B9%E6%B3%95"><span class="nav-number">2.2.3.</span> <span class="nav-text">3.更新事务状态方法和更新XID文件头方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E5%88%9B%E5%BB%BA-begin-%E4%BA%8B%E5%8A%A1%E6%96%B9%E6%B3%95%E3%80%81%E5%88%9B%E5%BB%BA%E6%8F%90%E4%BA%A4%E4%BA%8B%E5%8A%A1%E6%96%B9%E6%B3%95%E3%80%81%E5%88%9B%E5%BB%BA%E5%9B%9E%E6%BB%9A%E4%BA%8B%E5%8A%A1%E6%96%B9%E6%B3%95"><span class="nav-number">2.2.4.</span> <span class="nav-text">4.创建 begin 事务方法、创建提交事务方法、创建回滚事务方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E5%88%9B%E5%BB%BA-isActive%E3%80%81isCommitted-%E5%92%8C-isAborted-%E6%96%B9%E6%B3%95"><span class="nav-number">2.2.5.</span> <span class="nav-text">5.创建 isActive、isCommitted 和 isAborted 方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-%E5%85%B3%E9%97%AD%E8%B5%84%E6%BA%90"><span class="nav-number">2.2.6.</span> <span class="nav-text">6.关闭资源</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E7%BC%93%E5%AD%98%E6%A1%86%E6%9E%B6%E5%92%8C%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E6%95%B0%E7%BB%84"><span class="nav-number">3.</span> <span class="nav-text">引用计数缓存框架和共享内存数组</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E7%AD%96%E7%95%A5%E7%9A%84%E7%BC%93%E5%AD%98%E6%A1%86%E6%9E%B6"><span class="nav-number">3.1.</span> <span class="nav-text">实现引用计数策略的缓存框架</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95%EF%BC%9A%E4%B8%8D%E5%9C%A8%E7%BC%93%E5%AD%98%E7%9A%84%E8%B5%84%E6%BA%90%E8%8E%B7%E5%8F%96%EF%BC%8C%E8%A2%AB%E9%A9%B1%E9%80%90%E7%9A%84%E8%B5%84%E6%BA%90%E5%86%99%E5%9B%9E"><span class="nav-number">3.1.1.</span> <span class="nav-text">1、抽象方法：不在缓存的资源获取，被驱逐的资源写回</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81get-%EF%BC%9A%E8%8E%B7%E5%8F%96%E8%B5%84%E6%BA%90%E6%96%B9%E6%B3%95"><span class="nav-number">3.1.2.</span> <span class="nav-text">2、get()：获取资源方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81release-%EF%BC%9A%E9%87%8A%E6%94%BE%E7%BC%93%E5%AD%98%E6%96%B9%E6%B3%95"><span class="nav-number">3.1.3.</span> <span class="nav-text">3、release()：释放缓存方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%E3%80%81close-%EF%BC%9A%E5%85%B3%E9%97%AD%E7%BC%93%E5%AD%98%E6%96%B9%E6%B3%95"><span class="nav-number">3.1.4.</span> <span class="nav-text">4、close()：关闭缓存方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E6%95%B0%E7%BB%84"><span class="nav-number">3.2.</span> <span class="nav-text">实现共享内存数组</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E9%A1%B5%E7%9A%84%E7%BC%93%E5%AD%98%E4%B8%8E%E7%AE%A1%E7%90%86DM"><span class="nav-number">4.</span> <span class="nav-text">数据页的缓存与管理DM</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E9%A1%B5%E9%9D%A2%E7%BC%93%E5%AD%98%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">4.1.</span> <span class="nav-text">数据页面缓存的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E5%AE%9A%E4%B9%89%E9%A1%B5%E9%9D%A2%E7%BB%93%E6%9E%84"><span class="nav-number">4.1.1.</span> <span class="nav-text">1、定义页面结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E5%AE%9A%E4%B9%89%E9%A1%B5%E9%9D%A2%E7%BC%93%E5%AD%98%E7%9A%84%E6%8E%A5%E5%8F%A3"><span class="nav-number">4.1.2.</span> <span class="nav-text">2、定义页面缓存的接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81%E9%A1%B5%E9%9D%A2%E7%BC%93%E5%AD%98%E7%9A%84%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0%E7%B1%BB"><span class="nav-number">4.1.3.</span> <span class="nav-text">3、页面缓存的具体实现类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%E3%80%81%E8%AE%B0%E5%BD%95%E6%95%B0%E6%8D%AE%E5%BA%93%E6%96%87%E4%BB%B6%E7%9A%84%E9%A1%B5%E6%95%B0"><span class="nav-number">4.1.4.</span> <span class="nav-text">4、记录数据库文件的页数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E9%A1%B5%E9%9D%A2%E7%AE%A1%E7%90%86%E5%AE%9E%E7%8E%B0"><span class="nav-number">4.2.</span> <span class="nav-text">数据页面管理实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E7%AC%AC%E4%B8%80%E9%A1%B5%E8%AE%BE%E8%AE%A1"><span class="nav-number">4.2.1.</span> <span class="nav-text">1、第一页设计</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E6%99%AE%E9%80%9A%E9%A1%B5%E8%AE%BE%E8%AE%A1"><span class="nav-number">4.2.2.</span> <span class="nav-text">2、普通页设计</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6%E4%B8%8E%E6%81%A2%E5%A4%8D%E7%AD%96%E7%95%A5"><span class="nav-number">5.</span> <span class="nav-text">日志文件与恢复策略</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%97%A5%E5%BF%97%E8%AF%BB%E5%86%99%E5%AE%9E%E7%8E%B0"><span class="nav-number">5.1.</span> <span class="nav-text">日志读写实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E6%97%A5%E5%BF%97%E7%9A%84%E6%A0%BC%E5%BC%8F"><span class="nav-number">5.1.1.</span> <span class="nav-text">1、日志的格式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E6%B1%82%E5%8D%95%E6%9D%A1%E6%97%A5%E5%BF%97%E7%9A%84%E6%A0%A1%E9%AA%8C%E5%92%8C"><span class="nav-number">5.1.2.</span> <span class="nav-text">2、求单条日志的校验和</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81%E8%AF%BB%E5%8F%96%E6%97%A5%E5%BF%97%E5%B9%B6%E8%BF%94%E5%9B%9E%E6%95%B0%E6%8D%AE"><span class="nav-number">5.1.3.</span> <span class="nav-text">3、读取日志并返回数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%E3%80%81%E6%A3%80%E9%AA%8C%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6"><span class="nav-number">5.1.4.</span> <span class="nav-text">4、检验日志文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5%E3%80%81%E5%90%91%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6%E5%86%99%E5%85%A5%E6%97%A5%E5%BF%97"><span class="nav-number">5.1.5.</span> <span class="nav-text">5、向日志文件写入日志</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%81%A2%E5%A4%8D%E7%AD%96%E7%95%A5"><span class="nav-number">5.2.</span> <span class="nav-text">恢复策略</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E5%8D%95%E7%BA%BF%E7%A8%8B"><span class="nav-number">5.2.1.</span> <span class="nav-text">1、单线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="nav-number">5.2.2.</span> <span class="nav-text">2、多线程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%81%A2%E5%A4%8D%E7%AD%96%E7%95%A5%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">5.3.</span> <span class="nav-text">恢复策略的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E8%A7%84%E5%AE%9A%E6%97%A5%E5%BF%97%E6%A0%BC%E5%BC%8F"><span class="nav-number">5.3.1.</span> <span class="nav-text">1、规定日志格式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E5%AE%9E%E7%8E%B0-recover-%E4%BE%8B%E7%A8%8B"><span class="nav-number">5.3.2.</span> <span class="nav-text">2、实现 recover 例程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81updateLog-%E5%92%8C-insertLog-%E7%9A%84%E9%87%8D%E5%81%9A%E5%92%8C%E6%92%A4%E9%94%80%E5%85%B7%E4%BD%93%E6%93%8D%E4%BD%9C"><span class="nav-number">5.3.3.</span> <span class="nav-text">3、updateLog 和 insertLog 的重做和撤销具体操作</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%A1%B5%E9%9D%A2%E7%B4%A2%E5%BC%95%E5%92%8C-DM-%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">6.</span> <span class="nav-text">页面索引和 DM 的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A1%B5%E9%9D%A2%E7%B4%A2%E5%BC%95%E5%AE%9E%E7%8E%B0"><span class="nav-number">6.1.</span> <span class="nav-text">页面索引实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81PageIndex-%E9%A1%B5%E9%9D%A2%E7%B4%A2%E5%BC%95%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">6.1.1.</span> <span class="nav-text">1、PageIndex 页面索引的实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E4%BB%8E-PageIndex-%E4%B8%AD%E8%8E%B7%E5%8F%96%E9%A1%B5%E9%9D%A2"><span class="nav-number">6.1.2.</span> <span class="nav-text">2、从 PageIndex 中获取页面</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81%E9%A1%B5%E9%9D%A2%E9%87%8D%E6%96%B0%E6%8F%92%E5%85%A5-PageIndex-%E4%B8%AD"><span class="nav-number">6.1.3.</span> <span class="nav-text">3、页面重新插入 PageIndex 中</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%E3%80%81%E5%88%9B%E5%BB%BA-DM-%E6%97%B6%E6%89%80%E9%9C%80%E7%9A%84%E5%B7%A5%E4%BD%9C"><span class="nav-number">6.1.4.</span> <span class="nav-text">4、创建 DM 时所需的工作</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DataItem-%E6%8A%BD%E8%B1%A1%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">6.2.</span> <span class="nav-text">DataItem 抽象的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81DataItem-%E7%9A%84%E7%BB%93%E6%9E%84%E5%92%8C%E6%97%A5%E5%BF%97%E7%BB%93%E6%9E%84"><span class="nav-number">6.2.1.</span> <span class="nav-text">1、DataItem 的结构和日志结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81data-%EF%BC%9A%E6%96%B9%E6%B3%95%E8%8E%B7%E5%8F%96-DataItem-%E6%95%B0%E6%8D%AE"><span class="nav-number">6.2.2.</span> <span class="nav-text">2、data()：方法获取 DataItem 数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81%E4%BF%AE%E6%94%B9-DataItem-%E7%9A%84%E7%9B%B8%E5%85%B3-before-unBefore-after-%E6%96%B9%E6%B3%95"><span class="nav-number">6.2.3.</span> <span class="nav-text">3、修改 DataItem 的相关 before();unBefore();after() 方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%E3%80%81release-%EF%BC%9A%E6%96%B9%E6%B3%95%E9%87%8A%E6%94%BE-DataItem-%E7%BC%93%E5%AD%98"><span class="nav-number">6.2.4.</span> <span class="nav-text">4、release()：方法释放 DataItem 缓存</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DM-%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">6.3.</span> <span class="nav-text">DM 的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E8%A7%A3%E6%9E%90-DM-%E7%9A%84-DataItem-%E7%BC%93%E5%AD%98%EF%BC%8C%E5%B9%B6%E8%8E%B7%E5%8F%96%E5%85%B6%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE"><span class="nav-number">6.3.1.</span> <span class="nav-text">1、解析 DM 的 DataItem 缓存，并获取其中的数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E9%87%8A%E6%94%BE-DM-%E7%9A%84-DataItem-%E7%BC%93%E5%AD%98%EF%BC%8C%E6%8A%8A%E6%95%B0%E6%8D%AE%E5%86%99%E5%9B%9E%E6%95%B0%E6%8D%AE%E6%BA%90"><span class="nav-number">6.3.2.</span> <span class="nav-text">2、释放 DM 的 DataItem 缓存，把数据写回数据源</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81%E5%88%9B%E5%BB%BA-DataManager-%E6%96%87%E4%BB%B6"><span class="nav-number">6.3.3.</span> <span class="nav-text">3、创建 DataManager 文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%E3%80%81%E5%88%9D%E5%A7%8B%E5%8C%96%E6%88%96%E6%A3%80%E9%AA%8C-DM-%E6%96%87%E4%BB%B6%E7%AC%AC%E4%B8%80%E9%A1%B5"><span class="nav-number">6.3.4.</span> <span class="nav-text">4、初始化或检验 DM 文件第一页</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5%E3%80%81read-insert-DM-%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0-R-%E5%92%8C-I"><span class="nav-number">6.3.5.</span> <span class="nav-text">5、read();insert(); DM 方法实现 R 和 I</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6%E3%80%81close-%E6%96%B9%E6%B3%95%EF%BC%8C%E5%85%B3%E9%97%AD-DM"><span class="nav-number">6.3.6.</span> <span class="nav-text">6、close();方法，关闭 DM</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AE%B0%E5%BD%95%E7%9A%84%E7%89%88%E6%9C%AC%E4%B8%8E%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BBVM"><span class="nav-number">7.</span> <span class="nav-text">记录的版本与事务隔离VM</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#MVCC"><span class="nav-number">7.1.</span> <span class="nav-text">MVCC</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%B0%E5%BD%95%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">7.2.</span> <span class="nav-text">记录的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E5%AD%98%E5%9C%A8-DataItem-%E4%B8%AD%E8%AE%B0%E5%BD%95"><span class="nav-number">7.2.1.</span> <span class="nav-text">1、存在 DataItem 中记录</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81Entry-%E4%B8%AD%E5%AD%98%E5%82%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F"><span class="nav-number">7.2.2.</span> <span class="nav-text">2、Entry 中存储的数据格式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81%E8%8E%B7%E5%8F%96%E8%AE%B0%E5%BD%95%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE"><span class="nav-number">7.2.3.</span> <span class="nav-text">3、获取记录中的数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%E3%80%81%E4%BF%AE%E6%94%B9%E8%BF%94%E5%9B%9E%E6%95%B0%E6%8D%AE"><span class="nav-number">7.2.4.</span> <span class="nav-text">4、修改返回数据</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="nav-number">7.3.</span> <span class="nav-text">事务的隔离级别</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E8%AF%BB%E5%B7%B2%E6%8F%90%E4%BA%A4-Read-Committed"><span class="nav-number">7.3.1.</span> <span class="nav-text">1、读已提交 Read Committed</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB-Repeatable-Read"><span class="nav-number">7.3.2.</span> <span class="nav-text">2、可重复读  Repeatable Read</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E6%A3%80%E6%B5%8B%E4%B8%8E-VM-%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">8.</span> <span class="nav-text">死锁检测与 VM 的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%89%88%E6%9C%AC%E8%B7%B3%E8%B7%83%E9%97%AE%E9%A2%98"><span class="nav-number">8.1.</span> <span class="nav-text">版本跳跃问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E7%89%88%E6%9C%AC%E8%B7%B3%E8%B7%83%E9%97%AE%E9%A2%98%E4%B8%BE%E4%BE%8B"><span class="nav-number">8.1.1.</span> <span class="nav-text">1、版本跳跃问题举例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E7%89%88%E6%9C%AC%E8%B7%B3%E8%B7%83%E6%A3%80%E6%9F%A5%E8%A7%A3%E5%86%B3"><span class="nav-number">8.1.2.</span> <span class="nav-text">2、版本跳跃检查解决</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E6%A3%80%E6%B5%8B"><span class="nav-number">8.2.</span> <span class="nav-text">死锁检测</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E7%AD%89%E5%BE%85%E5%85%B3%E7%B3%BB%E6%8A%BD%E8%B1%A1%E4%B8%BA%E5%9B%BE%E7%9A%84%E5%9B%BE%E7%BB%93%E6%9E%84"><span class="nav-number">8.2.1.</span> <span class="nav-text">1、等待关系抽象为图的图结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E9%81%87%E5%88%B0%E7%AD%89%E5%BE%85%E9%9C%80%E6%A3%80%E6%B5%8B%E6%AD%BB%E9%94%81"><span class="nav-number">8.2.2.</span> <span class="nav-text">2、遇到等待需检测死锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81%E7%BB%A7%E7%BB%AD%E7%AD%89%E5%BE%85"><span class="nav-number">8.2.3.</span> <span class="nav-text">3、继续等待</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%E3%80%81%E9%80%9A%E8%BF%87%E6%9F%A5%E7%9C%8B%E5%9B%BE%E4%B8%AD%E6%98%AF%E5%90%A6%E6%9C%89%E7%8E%AF%E6%9D%A5%E6%A3%80%E6%B5%8B%E6%AD%BB%E9%94%81"><span class="nav-number">8.2.4.</span> <span class="nav-text">4、通过查看图中是否有环来检测死锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5%E3%80%81%E9%87%8A%E6%94%BE%E9%94%81%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">8.2.5.</span> <span class="nav-text">5、释放锁的方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#VM-%E7%9A%84%E6%95%B4%E5%90%88%E5%AE%9E%E7%8E%B0"><span class="nav-number">8.3.</span> <span class="nav-text">VM 的整合实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81VM-%E6%8E%A5%E5%8F%A3%E5%8F%82%E6%95%B0%E5%92%8C%E5%9F%BA%E6%9C%AC%E6%96%B9%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">8.3.1.</span> <span class="nav-text">1、VM 接口参数和基本方法的实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81begin-commit-internAbort-%E6%96%B9%E6%B3%95%E5%AF%B9%E4%BA%8B%E5%8A%A1%E8%BF%9B%E8%A1%8C%E6%93%8D%E4%BD%9C"><span class="nav-number">8.3.2.</span> <span class="nav-text">2、begin();commit();internAbort();方法对事务进行操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81read-insert-delete-%E6%96%B9%E6%B3%95%E5%AF%B9%E6%95%B0%E6%8D%AE%E8%BF%9B%E8%A1%8C%E6%93%8D%E4%BD%9C"><span class="nav-number">8.3.3.</span> <span class="nav-text">3、read();insert();delete(); 方法对数据进行操作</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E7%AE%A1%E7%90%86IM"><span class="nav-number">9.</span> <span class="nav-text">索引管理IM</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%B4%A2%E5%BC%95"><span class="nav-number">9.1.</span> <span class="nav-text">二叉树索引</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91%E7%BB%93%E6%9E%84"><span class="nav-number">9.1.1.</span> <span class="nav-text">1、二叉树结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E6%A0%B9%E8%8A%82%E7%82%B9%E7%9A%84%E7%BB%93%E6%9E%84"><span class="nav-number">9.1.2.</span> <span class="nav-text">2、根节点的结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81searchNex-leafSearchRange-%E6%96%B9%E6%B3%95%E7%94%A8%E4%BA%8E%E8%BE%85%E5%8A%A9-B-%E6%A0%91%E5%81%9A%E6%8F%92%E5%85%A5%E5%92%8C%E6%90%9C%E7%B4%A2%E6%93%8D%E4%BD%9C"><span class="nav-number">9.1.3.</span> <span class="nav-text">3、searchNex(); leafSearchRange(); 方法用于辅助 B+ 树做插入和搜索操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%E3%80%81B-%E6%A0%91%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E4%B8%80%E4%BA%9B%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="nav-number">9.1.4.</span> <span class="nav-text">4、B+ 树的创建和一些基本操作</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%AF%E8%83%BD%E7%9A%84%E9%94%99%E8%AF%AF%E4%B8%8E%E6%81%A2%E5%A4%8D"><span class="nav-number">9.2.</span> <span class="nav-text">可能的错误与恢复</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AD%97%E6%AE%B5%E4%B8%8E%E8%A1%A8%E7%AE%A1%E7%90%86TBM"><span class="nav-number">10.</span> <span class="nav-text">字段与表管理TBM</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1%E3%80%81%E9%A6%96%E5%85%88%E6%98%AFSQL-%E8%A7%A3%E6%9E%90%E5%99%A8"><span class="nav-number">10.1.</span> <span class="nav-text">1、首先是SQL 解析器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2%E3%80%81%E5%8D%95%E4%B8%AA%E5%AD%97%E6%AE%B5%E4%BF%A1%E6%81%AF%E5%92%8C%E8%A1%A8%E4%BF%A1%E6%81%AF%E7%9A%84%E5%82%A8%E5%AD%98%E7%BB%93%E6%9E%84"><span class="nav-number">10.2.</span> <span class="nav-text">2、单个字段信息和表信息的储存结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3%E3%80%81%E6%A0%B9%E6%8D%AE-UID-%E8%AF%BB%E5%8F%96%E5%B9%B6%E8%A7%A3%E6%9E%90%E5%8D%95%E4%B8%AA%E5%AD%97%E6%AE%B5%E5%92%8C%E8%A1%A8%E4%BF%A1%E6%81%AF"><span class="nav-number">10.3.</span> <span class="nav-text">3、根据 UID 读取并解析单个字段和表信息</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4%E3%80%81%E6%8C%81%E4%B9%85%E5%8C%96%E4%BF%A1%E6%81%AF"><span class="nav-number">10.4.</span> <span class="nav-text">4、持久化信息</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5%E3%80%81%E9%93%BE%E8%A1%A8%E7%AE%A1%E7%90%86%E7%AE%A1%E7%90%86%E5%A4%9A%E5%BC%A0%E8%A1%A8"><span class="nav-number">10.5.</span> <span class="nav-text">5、链表管理管理多张表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TableManager"><span class="nav-number">10.6.</span> <span class="nav-text">TableManager</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8F%8A%E5%85%B6%E9%80%9A%E4%BF%A1%E8%A7%84%E5%88%99"><span class="nav-number">11.</span> <span class="nav-text">服务端客户端的实现及其通信规则</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#C-x2F-S-%E9%80%9A%E4%BF%A1"><span class="nav-number">11.1.</span> <span class="nav-text">C&#x2F;S 通信</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81CS%E4%B9%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84-Package"><span class="nav-number">11.1.1.</span> <span class="nav-text">1、CS之间通信的基本结构 Package</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E7%BC%96%E7%A0%81%E4%B8%8E%E8%A7%A3%E7%A0%81%E8%A7%84%E5%88%99"><span class="nav-number">11.1.2.</span> <span class="nav-text">2、编码与解码规则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81%E9%80%9A%E8%BF%87-Transporter-%E7%B1%BB%EF%BC%8C%E5%86%99%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81%E5%8F%91%E9%80%81%E4%BF%A1%E6%81%AF"><span class="nav-number">11.1.3.</span> <span class="nav-text">3、通过 Transporter 类，写入输出流发送信息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%E3%80%81Packager-%E4%B8%AD%E5%AF%B9%E5%A4%96%E6%8F%90%E4%BE%9B%E7%9A%84-send-%E5%92%8C-receive-%E6%96%B9%E6%B3%95"><span class="nav-number">11.1.4.</span> <span class="nav-text">4、Packager 中对外提供的 send 和 receive 方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Server-%E5%92%8C-Client-%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">11.2.</span> <span class="nav-text">Server 和 Client 的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%AE%9E%E7%8E%B0"><span class="nav-number">11.2.1.</span> <span class="nav-text">1、服务端实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">11.2.2.</span> <span class="nav-text">2、客户端的实现</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BB%93%E8%AF%AD"><span class="nav-number">12.</span> <span class="nav-text">结语</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="爱你的晶哥"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">爱你的晶哥</p>
  <div class="site-description" itemprop="description">对不起宝宝</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">7</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/JingHyy" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;JingHyy" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://space.bilibili.com/18957646?spm_id_from=333.1007.0.0" title="bilibili → https:&#x2F;&#x2F;space.bilibili.com&#x2F;18957646?spm_id_from&#x3D;333.1007.0.0" rel="noopener" target="_blank"><i class="fa fa-bold fa-fw"></i>bilibili</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://javaguide.cn/" title="https:&#x2F;&#x2F;javaguide.cn&#x2F;" rel="noopener" target="_blank">JavaGuide</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.programmercarl.com/" title="https:&#x2F;&#x2F;www.programmercarl.com&#x2F;" rel="noopener" target="_blank">Leetcode-master</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; Sun Jul 31 2022 08:00:00 GMT+0800 (中国标准时间) – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">爱你的晶哥</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>


  <script defer src="/lib/three/three.min.js"></script>
    <script defer src="/lib/three/canvas_lines.min.js"></script>


  















  

  

  

</body>
</html>
